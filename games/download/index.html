<!doctype html><title>Download!!!</title><meta content="width=device-width" name=viewport><style>body,html{margin:0;padding:0;background:#000;color:#fff;font-family:sans-serif}canvas{cursor:none;padding-left:0;padding-right:0;margin-left:auto;margin-right:auto;display:block}canvas:focus{outline:0}.lose,.note,.win{position:absolute;float:left;left:50%;top:50%;text-align:center;transform:translate(-50%,-50%);padding:20px;border-radius:4px;background:#fff;color:#000}.lose{background:red;color:#fff;display:none}.win{background:green;color:#fff;display:none}</style><h2 class=note id=note>Safely download the data before the it is disconnected!<br><br>Use arrow keys to move the data</h2><h2 class=lose id=lose>Disconnected :(</h2><h2 class=win id=win>Data downloaded 0%</h2><canvas id=canvas></canvas><script src=dist/gim.js></script><script>var _extends=Object.assign||function(t){for(var e,i=1;i<arguments.length;i++)for(var h in e=arguments[i])Object.prototype.hasOwnProperty.call(e,h)&&(t[h]=e[h]);return t};function win(t=0){let e=document.getElementById("win");e.style.display="initial",e.innerHTML="Data downloaded "+t+"%",document.getElementById("canvas").style.display="none"}function lose(){document.getElementById("lose").style.display="initial",document.getElementById("canvas").style.display="none"}function start(){document.getElementById("note").style.display="none",document.getElementById("canvas").focus(),game.start()}let game=new gim.Game("canvas",500,window.innerHeight);const Packet={x:game.canvas.width/2-25,y:50,width:40,height:40,speed:4,onKeyDown(t){"right"==t&&(packet.x+=this.speed),"left"==t&&(packet.x-=this.speed),"up"==t&&(packet.y-=this.speed),"down"==t&&(packet.y+=this.speed)},update(){if(!(0>=this.width))return this.x>=tunnel.x+tunnel.width-this.width&&(this.x=tunnel.x+tunnel.width-this.width-1,this.shrink()),this.x<=tunnel.x&&(this.x=tunnel.x+1,this.shrink()),0>=this.width?(game.stop(),console.log("Disconnected :("),void lose()):void 0},shrink(){this.width-=.05*Packet.width,this.height-=.05*Packet.height},grow(){this.width+=.05*Packet.width,this.height+=.05*Packet.height},render(t){t.fillStyle="#006CAA",t.fillRect(this.x,this.y,this.width,this.height)}},Tunnel={x:0,y:0,width:game.canvas.width,height:game.canvas.height,shrink(){this.width-=.4,this.x+=.2},update(){return 0>=this.width?void lose():void this.shrink()},render(t){t.fillStyle="#fff",t.fillRect(this.x,this.y,this.width,this.height)}},Obstacle={x:0,y:game.canvas.height,width:5,height:5,speed:8,isCollide(t){return this.x<t.x+t.width&&this.x+this.width>t.x&&this.y<t.y+t.height&&this.y+this.height>t.y},randomX(){this.x=Math.floor(Math.random()*(game.canvas.height-this.width))},randomSpeed(){this.speed=Math.ceil(7*Math.random()+3)},reset(){this.y=game.canvas.height,this.randomX(),this.randomSpeed()},update(t,e){this.y<-this.height&&this.reset(),this.isCollide(packet)&&(this.reset(),packet.shrink()),this.y==e.canvas.height&&tunnel.width<=Packet.width+15||(this.y-=this.speed)},render(t){t.fillStyle="#000",t.fillRect(this.x,this.y,this.width,this.height)}},Finish={x:0,y:game.canvas.height,width:Packet.width+10,height:20,isCollide(t){return this.x<t.x+t.width&&this.x+this.width>t.x&&this.y<t.y+t.height&&this.y+this.height>t.y},shrink(){0>=this.width||(this.width-=.4,this.x+=.2)},update(){if(this.x=game.canvas.width/2-this.width/2,this.isCollide(packet)){game.stop();let t=packet.width/Packet.width*100;return console.log("Data downloaded "+t+"%"),void win(t)}tunnel.width<=Packet.width+15&&(this.y-=2,this.shrink()),this.y,game.canvas.height},render(t){t.fillStyle="green",t.fillRect(this.x,this.y,this.width,this.height)}};let finish=_extends({},Finish),tunnel=_extends({},Tunnel),packet=_extends({},Packet),obstacles=[];for(let t,e=0;20>e;e++)t=_extends({},Obstacle),t.randomX(),t.randomSpeed(),obstacles.push(t);game.keyboard.on("down",((t,e)=>{packet.onKeyDown(t,e)})),game.on("update",((t,e)=>{tunnel.update(t,e),packet.update(t,e),finish.update(t,e),obstacles.forEach((i=>i.update(t,e)))})),game.on("render",(t=>{tunnel.render(t.ctx),packet.render(t.ctx),finish.render(t.ctx),obstacles.forEach((e=>e.render(t.ctx)))})),setTimeout(start,4e3)</script>