
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ColorCat</title>
  </head>
  <body style="background: #000; margin: 0; overflow: hidden;">
    <h1 style="color:white" id="loading">Loading...</h1>
    <canvas></canvas>
  <script type="module">
function t(t,e,n,i){return new(n||(n=Promise))(function(o,s){function r(t){try{l(i.next(t))}catch(t){s(t)}}function a(t){try{l(i.throw(t))}catch(t){s(t)}}function l(t){var e;t.done?o(t.value):(e=t.value,e instanceof n?e:new n(function(t){t(e)})).then(r,a)}l((i=i.apply(t,e||[])).next())})}"function"==typeof SuppressedError&&SuppressedError;class e{constructor(){this.lastUpdateSent=0,this.updateInterval=50,this.players={},this.myId=function(t){let e="";for(let n=0;n<t;n++)e+=String.fromCharCode(97+Math.floor(26*Math.random()));return e}(32),this.connect()}connect(){this.socket=new WebSocket("wss://relay.js13kgames.com/color-cat"),this.socket.onopen=()=>{console.log("Connected to socket")},this.socket.onmessage=t=>{let e;try{e=JSON.parse(t.data),this.receive(e)}catch(e){e instanceof SyntaxError?console.error("Invalid JSON",t.data):console.error(e)}},this.socket.onclose=()=>{console.error("Connection closed"),setTimeout(()=>this.connect(),500)},this.socket.onerror=t=>{console.error(t),setTimeout(()=>this.connect(),500)}}receive(t){if("update"===t.type){const e=t;this.players[e.id]=Object.assign(Object.assign({},t),{lastUpdate:(new Date).getTime()})}}update(t){if((new Date).getTime()-this.lastUpdateSent<this.updateInterval)return;if(this.socket.readyState!==WebSocket.OPEN)return;this.socket.send(JSON.stringify({type:"update",id:this.myId,position:t.position.toArray(),rotation:[t.rotation.x,t.rotation.y,t.rotation.z,t.rotation.w],color:t.color})),console.log(t.position.toArray()),this.lastUpdateSent=(new Date).getTime();const e=(new Date).getTime();for(const t in this.players)e-this.players[t].lastUpdate>1e4&&delete this.players[t]}}const n="@group(0) @binding(0)\nvar tex : texture_storage_2d<${presentationFormat}, write>;\n    @group(0) @binding(1)\n    var blockDataA : texture_storage_3d < r32uint, read_write>;\n    //@group(0) @binding(2)\n    //var blockDataB : texture_storage_3d < r32uint, read_write>;\n\n    @group(0) @binding(3)\n    var<uniform> cameraData : CameraData;\n    @group(0) @binding(4)\n    var<uniform> settings : Settings;\n\n    @group(0) @binding(5)\n    var<uniform> lightData : LightData;\n    \n    @group(0) @binding(6)\n    var<uniform> inputData : InputData;\n   \n    @group(0) @binding(7)\n    var<uniform> playerData : PlayerData;\n\n    struct PlayerData {\n        playerCount : i32,                   // 4 bytes\n        players : array<Player, 64>         // 64 * 48 bytes = 3072 bytes\n    }\n    struct Player {\n        position : vec3<f32>,  // 12 bytes\n        rotation : vec4<f32>,  // 16 bytes\n        color : vec4<f32>      // 16 bytes\n    }\n\n    struct Settings {\n        worldSizeX : u32,\n        worldSizeY : u32,\n        worldSizeZ : u32\n    }\n\n    struct CameraData {\n        screenWidth : u32,\n        screenHeight : u32,\n        position : vec3 < f32>,\n        direction : vec3 < f32>,\n        fov : f32\n    }\n\n    struct VoxelData {\n        block : u32,\n        color : vec4 < f32>\n    }\n\n    struct LightData {\n        lightCount : i32,\n        lights : array<Light, 512>\n    }\n\n    struct Light {\n        position : vec3 < f32>,\n        color : vec4 < f32>\n    }\n\n    struct InputData {\n        blocksChanged : array <ChangedBlock, 32>\n    }\n\n    struct Shape {\n        position : vec3 < f32>,\n        color : vec4 < f32>,\n        size : vec3 < f32>,\n    }\n\n    struct ChangedBlock {\n        position : vec3 < i32 >,\n        block : u32\n    }\n\n    fn Rotate2D(v : vec2 < f32>, a : f32) -> vec2 < f32>{\n        let SinA = sin(a);\n        let CosA = cos(a);\n        return vec2 < f32 > (v.x * CosA - v.y * SinA, v.y * CosA + v.x * SinA);\n    }\n\n    // rotate vector v by quaternion q (q = vec4(x,y,z,w))\n    fn quatRotate(v: vec3<f32>, q: vec4<f32>) -> vec3<f32> {\n        let u = vec3<f32>(q.x, q.y, q.z);\n        let s = q.w;\n        return 2.0 * dot(u, v) * u + (s * s - dot(u, u)) * v + 2.0 * s * cross(u, v);\n    }\n\n    // multiply two quaternions q1 * q2\n    fn quatMul(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {\n        return vec4<f32>(\n            a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,\n            a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,\n            a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w,\n            a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z\n        );\n    }\n\n    fn GetVoxel(c : vec3 < f32>) -> VoxelData {\n        if (c.x < 0.0 || c.x >= f32(settings.worldSizeX) || c.y < 0.0 || c.y >= f32(settings.worldSizeY) || c.z < 0.0 || c.z >= f32(settings.worldSizeZ))\n        {\n            return VoxelData(0, vec4(0.0));\n        }\n\n        var pos = vec3 < i32 > (\n        i32(floor(c.x)),\n        i32(floor(c.y)),\n        i32(floor(c.z)),\n        );\n\n        var voxelData = textureLoad(blockDataA, pos);\n\n        var voxel = VoxelData(\n        voxelData.r >> 24,\n        vec4 < f32 > (\n        f32((voxelData.r >> 16) & 0xFF) / 255.0,\n        f32((voxelData.r >> 8) & 0xFF) / 255.0,\n        f32(voxelData.r & 0xFF) / 255.0,\n        1.0\n        ));\n\n        return voxel;\n    }\n\n    struct HitInfo{\n        normal : vec3 < f32>,\n        dist : f32,\n        pos : vec3 < f32>,\n        block : VoxelData\n    };\n\n\n    fn RayCast(origin: vec3<f32>, dir: vec3<f32>) -> HitInfo {\n        let invDir = 1.0 / dir; // pre-compute to avoid slow divisions\n        var pos = origin;       // may be clamp/intersect-ed to grid bounds\n        var tmax = 0.0;\n        var voxel: VoxelData;\n        let originVoxelPos = floor(origin);\n        var prevBlockPos: vec3<f32>;\n\n        for (var i = 0; i < 256; i++) {\n            let voxelPos = floor(pos);\n            voxel = GetVoxel(voxelPos);\n\n            if (voxel.block != 0 &&\n            (\n            originVoxelPos.x != voxelPos.x ||\n            originVoxelPos.y != voxelPos.y ||\n            originVoxelPos.z != voxelPos.z\n            )) { break; } // found hit at tmax\n\n            prevBlockPos = voxelPos;\n            let cellMin = voxelPos;\n            let cellMax = cellMin + 1.0;\n            let time = IntersectAABB(origin, invDir, cellMin, cellMax);\n\n            tmax = time.y + 0.0001;\n            pos = origin + tmax * dir;\n        }\n        \n\n        return HitInfo(\n            normalize(prevBlockPos - floor(pos)),\n            tmax,                    // distance to hit point\n            pos,                     // hit position\n            voxel                    // voxel data at hit position\n        );\n    }\n\n    // AABB intersection slab style\n    fn IntersectAABB(origin: vec3<f32>, invDir: vec3<f32>, bbMin: vec3<f32>, bbMax: vec3<f32>) -> vec2<f32> {\n        var t0 = (bbMin - origin) * invDir;\n        var t1 = (bbMax - origin) * invDir;\n\n        let temp = t0;\n        t0 = min(temp, t1);\n        t1 = max(temp, t1);\n\n        let tmin = max(max(t0.x, t0.y), t0.z);\n        let tmax = min(min(t1.x, t1.y), t1.z);\n\n        return vec2(tmin, tmax);\n    }\n\n    fn intersectAABBCatShapes(origin: vec3<f32>, dir: vec3<f32>) -> HitInfo {\n        let catShapes = array<Shape, 9>(\n            // Body\n            Shape(vec3<f32>(-.25,.25,-.5), vec4<f32>(.2, .2, .2, 1), vec3<f32>(.5, .5, 1.5)),\n            // Head\n            Shape(vec3<f32>(-.3,.35,-.55), vec4<f32>(.2, .2, .2, 1), vec3<f32>(.6, .6, .6)),\n            // feet\n            Shape(vec3<f32>(-.2,0.0,-.4), vec4<f32>(.2, .2, .2, 1), vec3<f32>(.1, .4, .1)),\n            Shape(vec3<f32>(.0,0.0,-.4), vec4<f32>(.2, .2, .2, 1), vec3<f32>(.1, .4, .1)),\n            Shape(vec3<f32>(-.2,0.0,.4), vec4<f32>(.2, .2, .2, 1), vec3<f32>(.1, .4, .1)),\n            Shape(vec3<f32>(.0,0.0,.4), vec4<f32>(.2, .2, .2, 1), vec3<f32>(.1, .4, .1)),\n            // tail\n            Shape(vec3<f32>(0.0,.5,1.0), vec4<f32>(.2, .2, .2, 1), vec3<f32>(.1, .7, .1)),\n            // ears\n            Shape(vec3<f32>(-.25,.95,-.5), vec4<f32>(.2, .2, .2, 1), vec3<f32>(.1, .1, .1)),\n            Shape(vec3<f32>(.15,.95,-.5), vec4<f32>(.2, .2, .2, 1), vec3<f32>(.1, .1, .1)),\n        );\n\n        var hitInfo = HitInfo(vec3<f32>(0.0), 0.0, vec3<f32>(0.0), VoxelData(0, vec4(0.0)));\n        let invDir = 1.0 / dir;\n\n        var bestDist = 10000.0;\n        \n        for (var i = 0; i < playerData.playerCount; i++) {\n            let player = playerData.players[i];\n            let offset = player.position + vec3<f32>(0.0, -1.5, 0.0);\n\n            // extract yaw-only rotation from player's quaternion (ignore pitch and roll)\n            // quaternion -> yaw (around Y) extraction\n            // yaw = atan2(2*(w*y + z*x), 1 - 2*(y*y + x*x)) but we build a yaw-only quaternion below\n            let px = player.rotation.x;\n            let py = player.rotation.y;\n            let pz = player.rotation.z;\n            let pw = player.rotation.w;\n\n            // compute yaw angle from quaternion\n            let siny_cosp = 2.0 * (pw * py + pz * px);\n            let cosy_cosp = 1.0 - 2.0 * (px * px + py * py);\n            let yaw = atan2(siny_cosp, cosy_cosp);\n\n            // build yaw-only quaternion (axis Y)\n            let half = yaw * 0.5;\n            let yawQuat = vec4<f32>(0.0, sin(half), 0.0, cos(half));\n\n            // use conjugate of yawQuat and apply 180-degree flip\n            let invYaw = vec4<f32>(-yawQuat.x, -yawQuat.y, -yawQuat.z, yawQuat.w);\n            let rot180 = vec4<f32>(0.0, 1.0, 0.0, 0.0);\n            let invRotWithFlip = quatMul(invYaw, rot180);\n\n            let localOrigin = quatRotate(origin - offset, invRotWithFlip);\n            let localDir = quatRotate(dir, invRotWithFlip);\n\n            for (var j = 0; j < 9; j++) {\n                var shape = catShapes[j];\n\n                var newHitInfo = intersectWithShape(localOrigin, localDir, shape);\n                if (newHitInfo.block.block != 0) {\n                    // convert hit position and normal back into world-space by undoing the 180 flip and rotating and adding the offset\n                    // rotate back using yaw-only rotation and undo 180 flip\n                    let flipBack = quatMul(yawQuat, rot180);\n                    newHitInfo.pos = quatRotate(newHitInfo.pos, flipBack) + offset;\n                    newHitInfo.normal = quatRotate(newHitInfo.normal, flipBack);\n\n                    if (newHitInfo.dist < bestDist) {\n                        bestDist = newHitInfo.dist;\n                        hitInfo = newHitInfo;\n                    }\n                }\n            }\n        }\n\n        return hitInfo;\n    }\n\n    fn intersectWithShape(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, shape: Shape) -> HitInfo {\n        let boxMin = shape.position;\n        let boxMax = shape.position + shape.size;\n\n        var hitInfo = HitInfo(vec3<f32>(0.0), 0.0, vec3<f32>(0.0), VoxelData(0, vec4(0.0)));\n\n        let invDir = 1.0 / rayDirection; // pre-compute to avoid slow divisions\n        let time = IntersectAABB(rayOrigin, invDir, boxMin, boxMax);\n\n        // time.x = tmin, time.y = tmax\n        if (time.x < time.y && time.y > 0.0) {\n            hitInfo.dist = time.x;\n            // compute world hit position (in rayOrigin space)\n            hitInfo.pos = rayOrigin + rayDirection * hitInfo.dist;\n\n            // determine which axis produced tmin to approximate normal\n            let t0 = (boxMin - rayOrigin) * invDir;\n            let t1 = (boxMax - rayOrigin) * invDir;\n            var tminVec = min(t0, t1);\n            var tmaxVec = max(t0, t1);\n\n            // find largest component of tminVec -> the axis of entry\n            if (tminVec.x >= tminVec.y && tminVec.x >= tminVec.z) {\n                hitInfo.normal = vec3<f32>(sign(-rayDirection.x), 0.0, 0.0);\n            } else if (tminVec.y >= tminVec.x && tminVec.y >= tminVec.z) {\n                hitInfo.normal = vec3<f32>(0.0, sign(-rayDirection.y), 0.0);\n            } else {\n                hitInfo.normal = vec3<f32>(0.0, 0.0, sign(-rayDirection.z));\n            }\n\n            hitInfo.block = VoxelData(1, shape.color);\n        }\n\n        return hitInfo;\n    }\n\n    fn vec3Distance(a : vec3 < f32>, b : vec3 < f32>) -> f32 {\n        return sqrt(dot(a - b, a - b));\n    }\n\n    fn rand(seed : f32) -> f32 {\n        return fract(sin(seed * 12.9898) * 43758.5453);\n    }\n\n    @compute @workgroup_size(8, 8, 1) fn render(@builtin(global_invocation_id) id : vec3u)\n    {\n        let Pixel = id.xy;\n        let Resolution = textureDimensions(tex).xy;\n        let AspectRatio = f32(Resolution.y) / f32(Resolution.x);\n\n        if (id.x >= Resolution.x || id.y >= Resolution.y)\n        {\n            return;\n        }\n\n        let FragCoord = vec2 < f32 > (f32(Pixel.x) + .5, f32(Resolution.y - Pixel.y) - .5);\n\n        let UV = 2. * FragCoord / vec2 < f32 > (Resolution) - 1.;\n\n        let fovScale = tan(radians(cameraData.fov) * 0.5);\n        let aspect = f32(cameraData.screenWidth) / f32(cameraData.screenHeight);\n        let uv = UV * vec2 < f32 > (aspect, 1.0) * fovScale;\n\n        let forward = normalize(cameraData.direction);\n        let worldUp = vec3 < f32 > (0.0, 1.0, 0.0);\n        let right = normalize(cross(forward, worldUp));\n        let up = cross(right, forward);\n\n        var RayDirection = normalize(forward + uv.x * right + uv.y * up);\n\n        var RayPosition = cameraData.position;\n\n\n        let DirectionRotation = Rotate2D(RayDirection.xz, 0);\n        let PositionRotation = Rotate2D(RayPosition.xz, 0);\n\n        RayDirection = vec3 < f32 > (DirectionRotation.x, RayDirection.y, DirectionRotation.y);\n\n        RayPosition = vec3 < f32 > (PositionRotation.x, RayPosition.y, PositionRotation.y);\n\n        var Primary = intersectAABBCatShapes(RayPosition, RayDirection);\n\n        let BlockPrimary = RayCast(RayPosition, RayDirection);\n\n        if (Primary.block.block == 0 || BlockPrimary.dist < Primary.dist) {\n            Primary = BlockPrimary;\n            // Primary.block.color = vec4(0.75, 0.75, 0.75, 1.0);\n        }\n\n        var color = vec4(0.0);\n\n        if (Primary.block.color.a == 0)\n        {\n            textureStore(tex, Pixel, vec4(0.0));\n            return;\n        }\n\n        for (var i = 0; i < lightData.lightCount; i++)\n        {\n            let light = lightData.lights[i];\n            let lightDist = vec3Distance(Primary.pos, light.position);\n\n            if (lightDist > (light.color.a * 64.0))\n            {\n                continue;\n            }\n\n            let bias = .001;\n            var shadowRayStart = Primary.pos + Primary.normal * bias;\n\n            let catHit = intersectAABBCatShapes(shadowRayStart, normalize(light.position - shadowRayStart));\n\n\n            let shadowRay = RayCast(shadowRayStart, normalize(light.position - shadowRayStart));\n\n            if (catHit.block.block == 0 || catHit.dist > shadowRay.dist) {\n\n                if (shadowRay.dist > lightDist - bias)\n                {\n                    //textureStore(tex, Pixel, Primary.block.color * ((1.0 - lightDist / 16.0) * shadowRay.block.color));\n                    color += ((1.0 - lightDist / (light.color.a * 64.0)) * light.color);\n                } else if (shadowRay.dist > lightDist - 2) {\n                    let hitBlockPos = floor(shadowRay.pos);\n                    let lightBlockPos = floor(light.position);\n\n                    if (hitBlockPos.x == lightBlockPos.x &&\n                        hitBlockPos.y == lightBlockPos.y &&\n                        hitBlockPos.z == lightBlockPos.z)\n                    {\n                        color += ((1.0 - lightDist / (light.color.a * 64.0)) * light.color);\n                    }\n                }\n            }\n        }\n\n        textureStore(tex, Pixel, Primary.block.color * color);\n        // textureStore(tex, Pixel, vec4(\n        //     (1 - (Primary.dist / 16.0)) * Primary.block.color.r,\n        //     (1 - (Primary.dist / 16.0)) * Primary.block.color.g,\n        //     (1 - (Primary.dist / 16.0)) * Primary.block.color.b,\n        //     1.0\n        // ));\n\n        \n    }\n\n    @compute @workgroup_size(1) fn light(@builtin(global_invocation_id) id : vec3u)\n    {\n        let light = lightData.lights[0];\n\n        if (GetVoxel(light.position).block == 2)\n        {\n            return;\n        }\n\n        if (light.position.x < 0.0 || light.position.x >= f32(settings.worldSizeX) ||\n        light.position.y < 0.0 || light.position.y >= f32(settings.worldSizeY) ||\n        light.position.z < 0.0 || light.position.z >= f32(settings.worldSizeZ))\n        {\n            return;\n        }\n\n    \n        textureStore(blockDataA, vec3u(light.position.xyz), vec4u(\n        u32(light.color.r * 255.0),\n        u32(light.color.g * 255.0),\n        u32(light.color.b * 255.0),\n        u32(light.color.a * 255.0)\n        ));\n\n        //re(tex, Pixel, light);\n    }\n\n    @compute @workgroup_size(1) fn input(@builtin(global_invocation_id) id : vec3u)\n    {\n            //textureStore(blockDataA, vec3u(2,1,2), vec4u(0, 0, 0, 0));\n\n        for (var i = 0; i < 32; i++)\n        {\n            var blockChange = inputData.blocksChanged[i];\n            //blockChange.position = vec3<i32>(3,1,3);\n\n\n            if (blockChange.position.x < 0 || blockChange.position.x >= i32(settings.worldSizeX) ||\n            blockChange.position.y < 0 || blockChange.position.y >= i32(settings.worldSizeY) ||\n            blockChange.position.z < 0 || blockChange.position.z >= i32(settings.worldSizeZ))\n            {\n                let x = 1;\n                continue;\n            }\n\n            // disable editing for the game demo\n            // textureStore(blockDataA, vec3u(blockChange.position), vec4u(blockChange.block, 0, 0, 0));\n            // textureStore(tex, vec2u(blockChange.position.xy), vec4(1.0));\n        }\n    }\n";class i{constructor(t,e,n){t instanceof i?(this.x=t.x,this.y=t.y,this.z=t.z):(this.x=null!=t?t:0,this.y=null!=e?e:0,this.z=null!=n?n:0)}toString(){return`${this.x},${this.y},${this.z}`}distanceTo(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return Math.sqrt(e*e+n*n+i*i)}subtract(t){return new i(this.x-t.x,this.y-t.y,this.z-t.z)}mul(t){return new i(this.x*t,this.y*t,this.z*t)}static min(t,e){return new i(Math.min(t.x,e.x),Math.min(t.y,e.y),Math.min(t.z,e.z))}static max(t,e){return new i(Math.max(t.x,e.x),Math.max(t.y,e.y),Math.max(t.z,e.z))}clone(){return new i(this.x,this.y,this.z)}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}normalize(){const t=this.length();return t>0&&(this.x/=t,this.y/=t,this.z/=t),this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,o=t.x,s=t.y,r=t.z,a=t.w,l=2*(s*i-r*n),c=2*(r*e-o*i),h=2*(o*n-s*e);return this.x=e+a*l+s*h-r*c,this.y=n+a*c+r*l-o*h,this.z=i+a*h+o*c-s*l,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}toArray(){return[this.x,this.y,this.z]}static fromArray(t){return new i(t[0],t[1],t[2])}}i.LEFT=new i(-1,0,0),i.RIGHT=new i(1,0,0),i.DOWN=new i(0,-1,0),i.UP=new i(0,1,0),i.BACK=new i(0,0,-1),i.BACKWARD=i.BACK,i.FORWARD=new i(0,0,1),i.Directions=[i.UP,i.LEFT,i.RIGHT,i.BACK,i.FORWARD,i.DOWN];const o=[{id:"x",position:[55.5,9.5,20.5],color:[0,0,1,.5],playerColor:[0,0,1,.6]},{id:"magenta",position:[88.5,9.5,233.5],color:[1,0,1,.5],playerColor:[1,0,1,.6]},{id:"cyan",position:[173.5,7.5,39.5],color:[.5,0,1,.6],playerColor:[.5,0,1,.6]},{id:"lime",position:[209.5,9.5,166.5],color:[.5,1,.5,.6],playerColor:[.5,1,.5,.6]},{id:"white",position:[232.5,10.5,217.5],color:[1,1,1,.75],playerColor:[1,1,1,.75]}];function s(t){const e=new ArrayBuffer(48),n=new DataView(e);return n.setUint32(0,t.screenWidth,!0),n.setUint32(4,t.screenHeight,!0),n.setFloat32(16,t.position[0],!0),n.setFloat32(20,t.position[1],!0),n.setFloat32(24,t.position[2],!0),n.setFloat32(32,t.direction[0],!0),n.setFloat32(36,t.direction[1],!0),n.setFloat32(40,t.direction[2],!0),n.setFloat32(44,t.fov,!0),e}function r(t){const e=new ArrayBuffer(16400),n=new DataView(e);n.setInt32(0,t.lightCount,!0);for(let e=0;e<Math.min(t.lights.length,512);e++){const i=t.lights[e],o=16+32*e;n.setFloat32(o+0,i.position[0],!0),n.setFloat32(o+4,i.position[1],!0),n.setFloat32(o+8,i.position[2],!0),n.setFloat32(o+16,i.color[0],!0),n.setFloat32(o+20,i.color[1],!0),n.setFloat32(o+24,i.color[2],!0),n.setFloat32(o+28,i.color[3],!0)}return e}function a(t){const e=new ArrayBuffer(3088),n=new DataView(e);n.setInt32(0,t.playerCount,!0);for(let e=0;e<Math.min(t.players.length,64);e++){const i=t.players[e],o=16+48*e;n.setFloat32(o+0,i.position[0],!0),n.setFloat32(o+4,i.position[1],!0),n.setFloat32(o+8,i.position[2],!0),n.setFloat32(o+16,i.rotation[0],!0),n.setFloat32(o+20,i.rotation[1],!0),n.setFloat32(o+24,i.rotation[2],!0),n.setFloat32(o+28,i.rotation[3],!0),n.setFloat32(o+32,i.color[0],!0),n.setFloat32(o+36,i.color[1],!0),n.setFloat32(o+40,i.color[2],!0),n.setFloat32(o+44,i.color[3],!0)}return e}function l(t){const e=new ArrayBuffer(512),n=new DataView(e);for(let e=0;e<Math.min(t.blocksChanged.length,32);e++){const i=t.blocksChanged[e],o=16*e;n.setInt32(o+0,i.position[0],!0),n.setInt32(o+4,i.position[1],!0),n.setInt32(o+8,i.position[2],!0),n.setUint32(o+12,i.block,!0)}return e}class c{constructor(t){this.sceneLights=[],this.size=256;const e=t.getContext("webgpu");if(!e)throw new Error("Failed to get WebGPU context");this.context=e}init(){return t(this,void 0,void 0,function*(){var t;const e=yield null===(t=navigator.gpu)||void 0===t?void 0:t.requestAdapter();if(!e){const t=document.createElement("h1");throw t.innerText='WebGPU not supported, please enable the feature flag to use WebGPU or try a different browser. For Chrome, go to chrome://flags/#enable-vulkan. For Safari Advanced > Experimental Features and enable "WebGPU". For Firefox, got to about:config and enable "dom.webgpu.enabled" and "gfx.webrender.all".',t.style.position="absolute",t.style.top="20%",t.style.left="50%",t.style.transform="translate(-50%, -50%)",t.style.color="white",t.style.backgroundColor="black",t.style.padding="20px",t.style.borderRadius="10px",document.body.appendChild(t),new Error("Failed to get GPU adapter")}const i=e.features.has("bgra8unorm-storage"),s=yield null==e?void 0:e.requestDevice({requiredFeatures:i?["bgra8unorm-storage"]:[]});if(!s)throw new Error("Failed to get GPU device");this.device=s;const c=navigator.gpu.getPreferredCanvasFormat();this.context.configure({device:s,format:c,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING});const h=Array(this.size*this.size*this.size).fill([0,0,0,0]);function u(t){return function(){var e=t+=1831565813;return e=Math.imul(e^e>>>15,1|e),(((e^=e+Math.imul(e^e>>>7,61|e))^e>>>14)>>>0)/4294967296}}let p={gradients:{},memory:{},rng:u(4658),rand_vect:function(){const t=2*this.rng()*Math.PI;return{x:Math.cos(t),y:Math.sin(t)}},dot_prod_grid:function(t,e,n,i){const o=`${n},${i}`;let s=this.gradients[o];const r=t-n,a=e-i;return s||(s=this.rand_vect(),this.gradients[o]=s),r*s.x+a*s.y},smootherstep:function(t){return 6*t**5-15*t**4+10*t**3},interp:function(t,e,n){return e+this.smootherstep(t)*(n-e)},seed:function(t){this.gradients={},this.memory={};const e=void 0===t?4658:t>>>0;this.rng=u(e)},get:function(t,e){const n=`${t},${e}`;if(Object.prototype.hasOwnProperty.call(this.memory,n))return this.memory[n];const i=Math.floor(t),o=Math.floor(e),s=this.dot_prod_grid(t,e,i,o),r=this.dot_prod_grid(t,e,i+1,o),a=this.dot_prod_grid(t,e,i,o+1),l=this.dot_prod_grid(t,e,i+1,o+1),c=this.interp(t-i,s,r),h=this.interp(t-i,a,l),u=this.interp(e-o,c,h);return this.memory[n]=u,u}};console.log("Generating world...");for(let t=0;t<this.size;t++)for(let e=0;e<this.size;e++)for(let n=0;n<this.size;n++){const i=t+e*this.size+n*this.size*this.size;if(t<16&&n<16)e<=5&&(h[i]=[1,201,201,201]);else{const o=8*p.get(t/16,n/16),s=4*p.get((t+100)/32,(n+100)/32),r=2*p.get(t/32,n/32);if(e<Math.floor(o+s+r)+2){const t=Math.floor(100*Math.random()+50),e=Math.floor(100*Math.random()+50),n=Math.floor(100*Math.random()+50);h[i]=[1,t,e,n]}}this.size,this.size,this.size}for(const t of o){const e=Math.floor(t.position[0]),n=Math.floor(t.position[1]),i=Math.floor(t.position[2]);h[e+n*this.size+i*this.size*this.size]=[1,255*t.color[0],255*t.color[1],255*t.color[2]]}this.blockDataA=this.create3dTexture(h.map(t=>t[0]<<24|t[1]<<16|t[2]<<8|t[3]),this.size,this.size,this.size,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,"block data A"),this.blockDataB=this.create3dTexture(h.map(t=>t[0]<<24|t[1]<<16|t[2]<<8|t[3]),this.size,this.size,this.size,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,"block data B");const f=n.replace(/\$\{presentationFormat\}/g,c),d=s.createShaderModule({label:"Raycast shader module",code:f});this.renderPipeline=s.createComputePipeline({label:"Raycast pipeline",layout:"auto",compute:{entryPoint:"render",module:d}}),this.lightPipeline=s.createComputePipeline({label:"Lighting pipeline",layout:"auto",compute:{entryPoint:"light",module:d}}),this.inputPipeline=s.createComputePipeline({label:"Input pipeline",layout:"auto",compute:{entryPoint:"input",module:d}}),this.cameraUniformBuffer=s.createBuffer({size:48,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.settingsUniformBuffer=s.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const y=function(t){const e=new ArrayBuffer(16),n=new DataView(e);return n.setUint32(0,t.worldSizeX,!0),n.setUint32(4,t.worldSizeY,!0),n.setUint32(8,t.worldSizeZ,!0),e}({worldSizeX:this.size,worldSizeY:this.size,worldSizeZ:this.size});s.queue.writeBuffer(this.settingsUniformBuffer,0,y),this.lightDataUniformBuffer=s.createBuffer({size:16400,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const m=r({lightCount:1,lights:[{position:[8.5,3.5,8.5],color:[1,1,1,1]}]});s.queue.writeBuffer(this.lightDataUniformBuffer,0,m),this.playerDataUniformBuffer=s.createBuffer({size:3088,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const g=a({playerCount:1,players:[{position:[0,0,0],rotation:[0,0,0,1],color:[1,1,1,1]}]});s.queue.writeBuffer(this.playerDataUniformBuffer,0,g),this.inputUniformBuffer=s.createBuffer({size:512,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const v=l({blocksChanged:Array.from({length:32},()=>({position:[0,0,0],block:0}))});return s.queue.writeBuffer(this.inputUniformBuffer,0,v),h})}create3dTexture(t,e,n,i,o,s){const r=this.device.createTexture({label:(s||"")+" 3D texture",size:[e,n,i],format:"r32uint",dimension:"3d",usage:o});return this.device.queue.writeTexture({texture:r},new Uint32Array(t),{bytesPerRow:4*e,rowsPerImage:n},{width:e,height:n,depthOrArrayLayers:i}),r}render(t,e=[]){let n;if(t){const e=new i(0,0,.8).applyQuaternion(t.rotation);n=s({screenWidth:window.innerWidth,screenHeight:window.innerHeight,position:[t.position.x,t.position.y,t.position.z],direction:[e.x,e.y,e.z],fov:80})}else n=s({screenWidth:window.innerWidth,screenHeight:window.innerHeight,position:[0,0,0],direction:[0,0,0],fov:80});let c=null;if(t&&(t.blockChanges.length&&(c=l({blocksChanged:t.blockChanges.map(t=>({position:t.position.toArray(),block:t.block[0]<<24|t.block[1]<<16|t.block[2]<<8|t.block[3]}))})),t.blockChanges.forEach(t=>{2===t.block[0]?(console.log("Block changed:",t),console.log(this.sceneLights),this.sceneLights.push({position:t.position.clone().add(new i(.5,.5,.5)),color:new i(t.block[1],t.block[2],t.block[3]).multiplyScalar(1/255)})):2===t.oldBlock[0]&&(this.sceneLights=this.sceneLights.filter(e=>!e.position.equals(t.position.clone().add(new i(.5,.5,.5)))))}),t.blockChanges=[]),t)for(const e of o){if(((null==t?void 0:t.position.distanceTo(new i(...e.position)))||0)<3&&(console.log("Collected special block:",e.id),t.color=e.playerColor,!t.collectedLights.includes(e.id)&&(t.collectedLights.push(e.id),t.collectedLights.length===o.length))){console.log("All special blocks collected!"),t.color[3]=1;const e=document.createElement("h1");e.innerText="You found all the special blocks!",e.style.position="absolute",e.style.top="20%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.color="white",e.style.backgroundColor="black",e.style.padding="20px",e.style.borderRadius="10px",document.body.appendChild(e)}}const h=[];h.push({position:[8.5,5.5,8.5],color:[.5,.3,.4,.75]},{position:((null==t?void 0:t.position.clone())||new i(0,0,0)).add(new i(0,3,0)).toArray(),color:(null==t?void 0:t.color)||[1,1,1,0]},...o.map(t=>({position:t.position,color:t.color})));const u=h.map((t,e)=>({position:[t.position[0]+0,t.position[1]+0,t.position[2]+0],color:[1*t.color[0],1*t.color[1],1*t.color[2],1*t.color[3]]})),p=e.map(t=>({position:[t.position[0]+0,t.position[1]+3,t.position[2]+0],color:t.color})),f=r({lightCount:u.length+p.length,lights:[...u,...p]});this.device.queue.writeBuffer(this.cameraUniformBuffer,0,n),this.device.queue.writeBuffer(this.lightDataUniformBuffer,0,f),c&&this.device.queue.writeBuffer(this.inputUniformBuffer,0,c);const d=a({playerCount:Object.values(e).length,players:Object.values(e).map(t=>({position:t.position,rotation:t.rotation,color:t.color}))});this.device.queue.writeBuffer(this.playerDataUniformBuffer,0,d);const y=this.context.getCurrentTexture();let m=this.device.createBindGroup({layout:this.renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:y.createView()},{binding:1,resource:this.blockDataA.createView()},{binding:3,resource:{buffer:this.cameraUniformBuffer}},{binding:4,resource:{buffer:this.settingsUniformBuffer}},{binding:5,resource:{buffer:this.lightDataUniformBuffer}},{binding:7,resource:{buffer:this.playerDataUniformBuffer}}]}),g=this.device.createCommandEncoder({label:"raycast encoder"}),v=g.beginComputePass();v.setPipeline(this.renderPipeline),v.setBindGroup(0,m);const x=Math.ceil(y.width/8),b=Math.ceil(y.height/8);v.dispatchWorkgroups(x,b),v.end();let w=g.finish();this.device.queue.submit([w])}}class h{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(n),this}multiplyQuaternions(t,e){const n=t.x,i=t.y,o=t.z,s=t.w,r=e.x,a=e.y,l=e.z,c=e.w;return this.x=n*c+s*r+i*l-o*a,this.y=i*c+s*a+o*r-n*l,this.z=o*c+s*l+n*a-i*r,this.w=s*c-n*r-i*a-o*l,this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}}class u{constructor(){this.buttonsPressed={},this.buttonsHeld={},this.buttonsStartHeld={},this.buttonsReleased={},this.modifiers={ctrl:!1,shift:!1,alt:!1},this.mouseDeltaBetweenFrames={x:0,y:0},this.lastMousePosition={x:0,y:0},this.mouseDelta={x:0,y:0},this.mouseWheelBetweenFrameDelta=0,this.mouseWheelDelta=0,window.addEventListener("keydown",t=>{const e=t.key.toLowerCase();this.buttonsPressed[e]=!0,this.buttonsStartHeld[e]=performance.now(),this.modifiers.ctrl=t.ctrlKey,this.modifiers.shift=t.shiftKey,this.modifiers.alt=t.altKey}),window.addEventListener("keyup",t=>{const e=t.key.toLowerCase();this.buttonsReleased[e]=!0,delete this.buttonsHeld[e],delete this.buttonsStartHeld[e],this.modifiers.ctrl=t.ctrlKey,this.modifiers.shift=t.shiftKey,this.modifiers.alt=t.altKey}),window.addEventListener("mousemove",t=>{this.mouseDeltaBetweenFrames.x+=t.movementX,this.mouseDeltaBetweenFrames.y+=t.movementY}),window.addEventListener("wheel",t=>{this.mouseWheelBetweenFrameDelta+=t.deltaY}),window.addEventListener("mousedown",t=>{this.buttonsPressed[`mouse${t.button+1}`]=!0,this.buttonsStartHeld[`mouse${t.button+1}`]=performance.now(),this.modifiers.ctrl=t.ctrlKey,this.modifiers.shift=t.shiftKey,this.modifiers.alt=t.altKey}),window.addEventListener("mouseup",t=>{this.buttonsReleased[`mouse${t.button+1}`]=!0,delete this.buttonsHeld[`mouse${t.button+1}`],delete this.buttonsStartHeld[`mouse${t.button+1}`],this.modifiers.ctrl=t.ctrlKey,this.modifiers.shift=t.shiftKey,this.modifiers.alt=t.altKey})}update(t){for(const e in this.buttonsPressed)this.buttonsPressed[e]&&(this.buttonsHeld[e]?(this.buttonsHeld[e]+=t,this.buttonsPressed[e]=!1):this.buttonsHeld[e]=performance.now()-this.buttonsStartHeld[e]);for(const t in this.buttonsReleased)this.buttonsReleased[t]&&(delete this.buttonsPressed[t],this.buttonsHeld[t]?(this.buttonsHeld[t]=0,this.buttonsStartHeld[t]=0):this.buttonsReleased[t]=!1);this.mouseDelta.x=this.mouseDeltaBetweenFrames.x,this.mouseDelta.y=this.mouseDeltaBetweenFrames.y,this.mouseDeltaBetweenFrames.x=0,this.mouseDeltaBetweenFrames.y=0,this.mouseWheelDelta=this.mouseWheelBetweenFrameDelta,this.mouseWheelBetweenFrameDelta=0}}class p{constructor(t,e=new i(4,10,4)){this.cameraOffset=new i(0,.75,0),this.jumpStrength=20,this.jumpStrengthKickstart=25,this.jumping=!1,this.jumpHeld=0,this.maxJumpHold=100,this.jumpDuration=0,this.characterHeight=3,this.characterRadius=.45,this.position=new i(0,0,0),this.rotation=new h,this.color=[.1,.1,.1,1],this.velocity=new i(0,0,0),this.blockChanges=[],this.collectedLights=[],this.input=new u,this.position=e,this.blocks=t,this.color=[.5,.5,.5,.25]}RayCast(t,e){let n=new i(1/e.x,1/e.y,1/e.z);var o=t,s=0,r=[0,0,0,0];let a=t.clone().floor();for(var l=a.clone(),c=0;c<256;c++){let i=o.clone().floor();if(null===(r=this.getBlock(i)))break;if(0!=r[0]&&(a.x!=i.x||a.y!=i.y||a.z!=i.z))break;l=i.clone();let c=i.clone(),h=c.clone().addScalar(1);s=this.IntersectAABB(t,n,c,h).y+1e-4,o=t.clone().add(e.clone().multiplyScalar(s))}return console.log(c),console.log(o),console.log(r),{normal:l.clone().sub(o.clone().floor()).normalize(),dist:s,pos:o,block:r}}IntersectAABB(t,e,n,o){var s=n.sub(t).multiply(e),r=o.sub(t).multiply(e);let a=s;s=i.min(a,r),r=i.max(a,r);let l=Math.max(Math.max(s.x,s.y),s.z),c=Math.min(Math.min(r.x,r.y),r.z);return new i(l,c)}blockCast(t,e,n=100,i=.5){let o=t.clone();const s=e.clone().normalize().multiplyScalar(i);let r=0;for(;r<n;r+=i){const t=o.clone().floor(),e=this.getBlock(t);if(!e)return null;if(0!==e[0])return{pos:o,block:e};o.add(s)}return null}getBlock(t){const e=t.x+256*t.y+256*t.z*256;return this.blocks[e]||null}setBlock(t,e){const n=t.x+256*t.y+256*t.z*256,i=this.blocks[n];this.blocks[n]=e,this.blockChanges.push({position:t,block:e,oldBlock:i})}applyImpulse(t){this.velocity=this.velocity.add(t.multiplyScalar(.0025))}update(t){if(this.input.update(t),this.input.buttonsPressed[" "]&&(this.jumping||(this.jumpHeld=.025,this.jumping=!0,this.applyImpulse(new i(0,this.jumpStrengthKickstart,0)))),this.jumping){this.input.buttonsHeld[" "]&&(this.jumpHeld<=this.maxJumpHold?this.jumpHeld+=t:this.jumpHeld=this.maxJumpHold),this.jumpDuration+=t;1.25*this.jumpHeld>this.jumpDuration?this.applyImpulse(new i(0,this.jumpStrength*t,0)):(this.jumping=!1,this.jumpDuration=0,this.jumpHeld=0)}const e=new i(0,0,1).applyQuaternion(this.rotation),n=new i(-1,0,0).applyQuaternion(this.rotation);let o=new i(0,0,0);this.input.buttonsHeld.w&&(o=o.add(e)),this.input.buttonsHeld.s&&(o=o.add(e.clone().multiplyScalar(-1))),this.input.buttonsHeld.a&&(o=o.add(n.clone().multiplyScalar(-1))),this.input.buttonsHeld.d&&(o=o.add(n)),o=o.length()>0?o.normalize():o;const s=new i(this.velocity.x,0,this.velocity.z),r=s.dot(o);o.equals(new i(0,0,0))?s.length()>.1?this.applyImpulse(s.clone().multiplyScalar(-8*t)):this.applyImpulse(new i(8*-s.x*t,0,8*-s.z*t)):Math.abs(r)>1?(this.applyImpulse(new i(8*-s.x*t,0,8*-s.z*t)),this.applyImpulse(o.clone().multiplyScalar(1-r))):this.applyImpulse(o.clone().multiplyScalar(5*t));const a=.2*-this.input.mouseDelta.x*.01;this.rotation=this.rotation.multiply((new h).setFromAxisAngle(new i(0,1,0),a));const l=(new h).setFromAxisAngle(new i(1,0,0),.2*this.input.mouseDelta.y*.01);if((this.input.mouseDelta.y>0||this.input.mouseDelta.y<0)&&(this.rotation=this.rotation.multiply(l)),this.input.buttonsPressed.mouse1||this.input.buttonsPressed.mouse3){const t=new i(0,0,1).applyQuaternion(this.rotation),e=this.position.clone();let n=this.RayCast(e,t);n&&(this.input.buttonsPressed.mouse1?n.pos.sub(n.normal.clone().multiplyScalar(-.15)):this.input.buttonsPressed.mouse3)}const c=[.4];Array.from({length:8},(t,e)=>{const n=e/8*Math.PI*2;return new i(Math.cos(n),0,Math.sin(n))}).forEach(t=>{c.forEach(e=>{const n=this.position.clone();n.y-=this.characterHeight/2,n.y+=e;const o=this.blockCast(n.clone(),t,1,.005);if(o){const e=new i(o.pos.x,0,o.pos.z),n=new i(this.position.x,0,this.position.z).distanceTo(e);if(n<this.characterRadius){const e=t.clone().multiplyScalar(n-this.characterRadius);this.position.add(e);const o=new i(this.velocity.x,0,this.velocity.z),s=o.dot(t),r=s*o.length(),a=this.velocity.y;this.velocity.sub(t.clone().multiplyScalar(r)),this.velocity.multiplyScalar(1-Math.abs(s)/1),this.velocity.y=a}}})});const u=this.blockCast(this.position.clone(),new i(0,-1,0),this.characterHeight/2+2,.01),p=u?u.pos:null,f=p?this.position.y-this.characterHeight/2-p.y:10;f<0&&(this.position.y=this.position.y-f,this.velocity.y<0&&(this.velocity.y=0)),f>0&&this.velocity.y>-2&&this.applyImpulse(new i(0,-7.5*t,0)),this.position.x+=this.velocity.x*t*.01,this.position.y+=this.velocity.y*t*.01,this.position.z+=this.velocity.z*t*.01,this.position.y<-10&&(this.position=new i(4,10,4),this.velocity=new i(0,0,0))}}setTimeout(()=>{!function(){t(this,void 0,void 0,function*(){var t;const n=document.querySelector("canvas");if(!n)throw new Error("Canvas element not found");n.width=window.innerWidth,n.height=window.innerHeight;let i=performance.now();performance.now();const o=new c(n),s=yield o.init(),r=new p(s),a=new e;null===(t=document.querySelector("#loading"))||void 0===t||t.remove(),n.addEventListener("click",()=>{n.requestPointerLock()}),function t(){const e=performance.now()-i;i=performance.now(),performance.now(),r.update(e),o.render(r,Object.values(a.players)),a.update(r),requestAnimationFrame(t)}()})}()},100);
</script>
</body>
</html>
