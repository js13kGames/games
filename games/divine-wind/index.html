<!doctype html><script src=/2023/webxr/babylon.js></script><style>body,html{overflow:hidden;width:100%;height:100%;margin:0;padding:0}#renderCanvas{width:100%;height:100%;touch-action:none}#screenText{position:absolute;margin:auto;top:0;right:0;bottom:0;left:0;text-align:center;font-size:60px}</style><canvas id=renderCanvas></canvas><script>const BOTTOM_CENTER="bottom center",LEFT_CENTER="left center",RIGHT_CENTER="right center",TOP_CENTER="top center",OUTER="outer",OUTER_0="outer0",OUTER_1="outer1",CLOCKWISE="clockwise",CENTER="center",UPPER_LEFT="upper left corner",UPPER_RIGHT="upper right corner",LOWER_LEFT="lower left corner",LOWER_RIGHT="lower right corner",CELL_HEIGHT=.1,CELL_OUTER_ARC_THRESHOLD=.1,WALL_WIDTH=.005,INNER_RADIUS=.05,LAYERS=11,ANGLE_EQUALITY_THRESHOLD=.03,ANGULAR_SPEED=.7,LEVELS=7,SHIP_SPEED=3,LEVEL_TIME=20,LEVEL_COOLDOWN=3,HORIZON=200;function shuffle(e){for(let t=e.length-1;t>=1;t--){let i=randIntFromZero(t),a=e[i];e[i]=e[t],e[t]=a}}function randIntFromZero(e){return Math.floor(Math.random()*e)}function translateLocationToCoords(e,t,i){switch(i){case BOTTOM_CENTER:return new MazeCoordinates(e,t[e].length/2);case LEFT_CENTER:return new MazeCoordinates(e,3*t[e].length/4);case RIGHT_CENTER:return new MazeCoordinates(e,t[e].length/4);case TOP_CENTER:return new MazeCoordinates(e,0);default:console.error("Invalid maze location given: "+i)}}function translateMazeCoordinatesToWorldPos(e,t){let i=.1*(t.layer-.5)+.05,a=e.grid[t.layer].length,o=((t.cell+e.offsets[t.layer])%a+.5)*(2*Math.PI/a);return new BABYLON.Vector3(Math.sin(o)*i,Math.cos(o)*i+1,0)}function MazeCell(){this.outer0=!0,this.outer1=!0,this.clockwise=!0,this.root=this,this.findBaseRoot=function(){let e=this.root;for(;e!==e.root;)e=e.root;return e},this.updateRoot=function(){this.root=this.findBaseRoot()},this.copyRoot=function(e){this.root.root=e.root},this.updateRootsAndMatch=function(e){return this.updateRoot(),e.updateRoot(),this.root===e.root},this.knockOuterWall=function(){this.outer0=!1,this.outer1=!1},this.knockOuter0Wall=function(){this.outer0=!1},this.knockOuter1Wall=function(){this.outer1=!1},this.knockClockwiseWall=function(){this.clockwise=!1}}function MazeCoordinates(e,t){this.layer=e,this.cell=t}class Maze{constructor(e,t,i,a){this.grid=generate_maze(e,t,i,a),this.offsets=[];for(let e=0;e<this.grid.length;e++)this.offsets.push(0)}connectedNeighbors(e){const t=this.grid[e.layer][e.cell],i=this.offsets[e.layer],a=this.grid[e.layer].length;let o=[];if(e.layer<this.grid.length-1){const n=this.offsets[e.layer+1],r=this.grid[e.layer+1].length;if(2*a===r){const a=(2*i-n+r)%r;if(!t.outer0){let t=(2*e.cell+a)%r;o.push(new MazeCoordinates(e.layer+1,t))}if(!t.outer1){let t=(2*e.cell+1+a)%r;o.push(new MazeCoordinates(e.layer+1,t))}}else if(!t.outer0){const t=(i-n+r)%r;let a=(e.cell+t)%r;o.push(new MazeCoordinates(e.layer+1,a))}}if(e.layer>1){const t=this.offsets[e.layer-1],n=this.grid[e.layer-1].length;if(a===2*n){const a=e.cell+i;let r=(Math.floor(a/2)-t+n)%n;const s=a%2==0,l=this.grid[e.layer-1][r];s?l.outer0||o.push(new MazeCoordinates(e.layer-1,r)):l.outer1||o.push(new MazeCoordinates(e.layer-1,r))}else{const r=(i-t+n)%n;let s=(e.cell+r)%a;this.grid[e.layer-1][s].outer0||o.push(new MazeCoordinates(e.layer-1,s))}}if(!t.clockwise){const t=(e.cell+1)%a;o.push(new MazeCoordinates(e.layer,t))}const n=(e.cell-1+a)%a;return this.grid[e.layer][n].clockwise||o.push(new MazeCoordinates(e.layer,n)),o}setOffsets(e){this.offsets=e}scrambleOffsets(){for(let e=1;e<this.grid.length-1;e++)this.offsets[e]=randIntFromZero(this.grid[e].length)}}function generate_maze(e,t,i,a){const o=[];for(let t=0;t<e+1;t++){let e=[],i=.05+.1*t,a=2*Math.PI*i,n=0;if(0===t)n=Math.ceil(a/.1);else{let e=o[t-1].length;n=a/e>.1?2*e:e}for(let i=0;i<n;i++){const i=new MazeCell;e.push(i),0===t&&i.knockClockwiseWall()}o.push(e)}const n=[];for(let e=1;e<o.length;e++)for(let t=0;t<o[e].length;t++)n.push({layer:e,cell:t,wall:CLOCKWISE});for(let e=1;e<o.length-1;e++)if(o[e].length===o[e+1].length/2)for(let t=0;t<o[e].length;t++)n.push({layer:e,cell:t,wall:OUTER_0}),n.push({layer:e,cell:t,wall:OUTER_1});else for(let t=0;t<o[e].length;t++)n.push({layer:e,cell:t,wall:OUTER});shuffle(n);let r=0;for(let e=1;e<o.length;e++)r+=o[e].length;for(let e=0,t=r-1;e<n.length&&t>0;e++){let i=n[e],a=o[i.layer][i.cell];switch(i.wall){case OUTER:let e=o[i.layer+1][i.cell];if(a.updateRootsAndMatch(e))continue;a.knockOuterWall(),a.copyRoot(e),t--;break;case OUTER_0:let n=o[i.layer+1][2*i.cell];if(a.updateRootsAndMatch(n))continue;a.knockOuter0Wall(),a.copyRoot(n),t--;break;case OUTER_1:let r=o[i.layer+1][2*i.cell+1];if(a.updateRootsAndMatch(r))continue;a.knockOuter1Wall(),a.copyRoot(r),t--;break;case CLOCKWISE:let s=o[i.layer].length,l=o[i.layer][(i.cell+1)%s];if(a.updateRootsAndMatch(l))continue;a.knockClockwiseWall(),a.copyRoot(l),t--}}return knockBorderWall(e,o,i),knockBorderWall(e,o,a),o}function knockBorderWall(e,t,i){const a=translateLocationToCoords(e,t,i);t[a.layer][a.cell].knockOuterWall()}function solveMaze(e,t,i){const a=translateLocationToCoords(i.grid.length-1,i.grid,e),o=translateLocationToCoords(i.grid.length-1,i.grid,t);return rSolveMaze(i,a,[],new Set,o)}function rSolveMaze(e,t,i,a,o){let n=e.grid[t.layer][t.cell];if(a.has(n))return[];if(a.add(n),i.push(t),t.layer===o.layer&&t.cell===o.cell)return i;for(let n of e.connectedNeighbors(t)){let t=rSolveMaze(e,n,i.slice(),a,o);if(t.length>0)return t}return[]}class MazeRotationLayer{constructor(e,t,i,a){this.origin=e,this.wallMeshes=[],this.wallMaterial=new BABYLON.StandardMaterial("wall mat",i),this.offset=a,this.cellCount=t,this.snapAngles=[],this.currentAngle=0;let o=2*Math.PI/t;for(let e=0,i=0;i<t;i++,e+=o)this.snapAngles.push(e);this.currentAngle=2*Math.PI-this.snapAngles[this.offset]}update(e){const t=Math.abs(this.origin.rotation.z-this.currentAngle);t>.03?t>Math.PI?(this.origin.rotation.z>this.currentAngle?this.origin.rotation.z+=.7*e:this.origin.rotation.z+=2*Math.PI-.7*e,this.origin.rotation.z%=2*Math.PI):this.origin.rotation.z>this.currentAngle?this.origin.rotation.z-=.7*e:this.origin.rotation.z+=.7*e:this.origin.rotation.z=this.currentAngle}addWallMesh(e){this.wallMeshes.push(e),e.material=this.wallMaterial}setWallColor(e){this.wallMaterial.diffuseColor=e}rotate(e){(e%=2*Math.PI)<0&&(e+=2*Math.PI),this.origin.rotation.z=(this.currentAngle+e)%(2*Math.PI)}endRotate(){this.offset=this.binarySearch(2*Math.PI-this.origin.rotation.z);let e=this.snapAngles[this.offset];this.currentAngle=2*Math.PI-e}binarySearch(e){let t=0,i=this.snapAngles.length-1,a=Math.floor((t+i)/2);for(;t<i;){if(this.snapAngles[a]===e)return a;e<this.snapAngles[a]?i=a-1:e>this.snapAngles[a]&&(t=a+1),a=Math.floor((t+i)/2)}return this.snapAngles[a]===e?a:e<this.snapAngles[a]?0===a||Math.abs(e-this.snapAngles[a])<Math.abs(e-this.snapAngles[a-1])?a:a-1:e>this.snapAngles[a]?a===this.snapAngles.length-1?Math.abs(e-this.snapAngles[a])<Math.abs(e-2*Math.PI)?a:0:Math.abs(e-this.snapAngles[a])<Math.abs(e-this.snapAngles[a+1])?a:a+1:void 0}}function initGraphicalMaze(e,t,i){let a=[];for(let o=0;o<e.grid.length;o++){let n=new BABYLON.TransformNode("layer "+o,t);n.setParent(i);let r=new MazeRotationLayer(n,e.grid[o].length,t,e.offsets[o]);a.push(r);let s=2*Math.PI/e.grid[o].length,l=.05+.1*o,h=[[]];for(let i=0,a=0;i<e.grid[o].length;i++,a+=s){let n=h[h.length-1];if(e.grid[o][i].outer0?(0===n.length&&n.push(new BABYLON.Vector3(l*Math.sin(a),l*Math.cos(a),0)),n.push(new BABYLON.Vector3(l*Math.sin(a+s/2),l*Math.cos(a+s/2),0))):n.length>0&&(h.push([]),n=h[h.length-1]),e.grid[o][i].outer1?(0===n.length&&n.push(new BABYLON.Vector3(l*Math.sin(a+s/2),l*Math.cos(a+s/2),0)),n.push(new BABYLON.Vector3(l*Math.sin(a+s),l*Math.cos(a+s),0))):n.length>0&&(h.push([]),n=h[h.length-1]),e.grid[o][i].clockwise){let e={path:[new BABYLON.Vector3(l*Math.sin(a+s),l*Math.cos(a+s),0),new BABYLON.Vector3((l-.1)*Math.sin(a+s),(l-.1)*Math.cos(a+s),0)],radius:.005,cap:BABYLON.Mesh.CAP_ALL},i=BABYLON.MeshBuilder.CreateTube("clockwise wall",e,t);i.isPickable=!1,i.setParent(r.origin),r.addWallMesh(i)}}for(let e of h){if(0===e.length)continue;let i={path:e,radius:.005,cap:BABYLON.Mesh.CAP_ALL},a=BABYLON.MeshBuilder.CreateTube("outer wall",i,t);a.isPickable=!1,a.setParent(r.origin),r.addWallMesh(a)}}return a}class GraphicalMaze{constructor(e,t){this.maze=e,this.origin=new BABYLON.TransformNode("maze origin",t),this.pickingPlane=BABYLON.MeshBuilder.CreateDisc("picking disc plane",{radius:.05+.1*(e.grid.length-1)},t);let i=new BABYLON.StandardMaterial("picking plane mat",t);i.alpha=.2,this.pickingPlane.material=i,this.pickingPlane.setParent(this.origin),this.pickingPlaneNormal=BABYLON.Vector3.Forward(),this.rotationLayers=initGraphicalMaze(e,t,this.origin),this.rotating=!1,this.rotatingLayer=0,this.initialRotatingVector=new BABYLON.Vector3,this.currPickVector=new BABYLON.Vector3,this.timestamp=new Date,this.isSolved=!1,t.registerBeforeRender((()=>{let e=this.timestamp;this.timestamp=new Date;let t=(this.timestamp-e)/1e3;this.update(t)}))}update(e){for(let t of this.rotationLayers)t.update(e)}setRotationX(e){this.origin.rotation.x=e,this.pickingPlaneNormal.y=Math.sin(e),this.pickingPlaneNormal.z=Math.cos(e)}unhightlightLayers(){if(!this.isSolved)for(let e of this.rotationLayers)e.setWallColor(BABYLON.Color3.Black())}highlightLayer(e){if(this.isSolved)return;this.unhightlightLayers();let t=Math.floor((e-.05)/.1)+1;0<t&&t<this.maze.grid.length-1&&this.rotationLayers[t].setWallColor(BABYLON.Color3.Red())}initRotateLayer(e,t){let i=Math.floor((e-.05)/.1)+1;0<i&&i<this.maze.grid.length-1&&(this.rotating=!0,this.rotatingLayer=i,t.subtractToRef(this.origin.position,this.initialRotatingVector))}rotateLayer(e){e.subtractToRef(this.origin.position,this.currPickVector);let t=BABYLON.Vector3.GetAngleBetweenVectorsOnPlane(this.initialRotatingVector,this.currPickVector,this.pickingPlaneNormal);this.rotationLayers[this.rotatingLayer].rotate(t)}endRotateLayer(){this.rotating&&(this.rotating=!1,this.rotationLayers[this.rotatingLayer].endRotate())}offsets(){let e=[];for(let t of this.rotationLayers)e.push(t.offset);return e}solved(){for(let e of(this.isSolved=!0,this.rotationLayers))e.setWallColor(new BABYLON.Color3(255/256,215/256,0))}destroy(){this.origin.dispose(),this.isSolved=!1}}class MazePather{constructor(){this.drawnPath=void 0,this.solution=[]}solveAndShow(e){this.drawnPath&&this.drawnPath.dispose();let t=this.solve(e),i=[];for(let a=1;a<t.length;a++)i.push([translateMazeCoordinatesToWorldPos(e,t[a-1]),translateMazeCoordinatesToWorldPos(e,t[a])]);this.drawnPath=BABYLON.MeshBuilder.CreateLineSystem("solution path",{lines:i}),this.drawnPath.color=new BABYLON.Color3(0,1,0)}solve(e){return this.solution=solveMaze(BOTTOM_CENTER,TOP_CENTER,e),this.solution}}class MongolShip{constructor(e,t,i){this.origin=new BABYLON.TransformNode("shippy",e),this.traveling=!1,this.beingBlownAway=!1;const a=BABYLON.MeshBuilder.CreateCylinder("hull",{height:.5,diameterTop:0,diameterBottom:.2},e);a.rotation.x=-Math.PI/2;const o=BABYLON.MeshBuilder.CreateCylinder("mast0",{height:.3,diameter:.02},e);o.position.y+=.15,o.position.z+=.12;const n=BABYLON.MeshBuilder.CreatePlane("sail0",{size:.25},e);n.position.y+=.3,n.position.z+=.1;const r=new BABYLON.StandardMaterial("shipMat");r.diffuseColor=new BABYLON.Color3(153/256,102/256,51/256);const s=new BABYLON.StandardMaterial("sailMat");s.emissiveColor=i?BABYLON.Color3.Red():new BABYLON.Color3(255/256,255/256,.78125),a.material=r,o.material=r,n.material=s;BABYLON.Mesh.MergeMeshes([a,o,n],!0,!1,null,!1,!0).setParent(this.origin),this.origin.position=t,this.timestamp=new Date,e.registerBeforeRender((()=>{let e=this.timestamp;this.timestamp=new Date;let t=(this.timestamp-e)/1e3;this.beingBlownAway?(this.origin.position.z+=3*t*10,this.origin.rotation.x+=Math.random(),this.origin.rotation.y+=Math.random(),this.origin.rotation.z+=Math.random(),this.origin.position.z>200&&(this.beingBlownAway=!1)):this.traveling&&(this.origin.position.z-=3*t,this.origin.position.z<0&&(this.traveling=!1))}))}setPosition(e,t,i){this.origin.position.x=e,this.origin.position.y=t,this.origin.position.z=i}resetRotation(){this.origin.rotation.x=0,this.origin.rotation.y=0,this.origin.rotation.z=0}resetTraveling(){this.traveling=!0,this.beingBlownAway=!1,this.resetRotation(),this.timestamp=new Date}blowAway(){this.beingBlownAway=!0,this.traveling=!1}}class ShipManager{constructor(e,t,i){this.ships=[],this.waveWidth=i;for(let i=0;i<t;i++)this.ships.push(new MongolShip(e,BABYLON.Vector3.Down(),0===i))}startWave(e,t,i=this.ships.length){let a=e*t;for(let e=0;e<i&&e<this.ships.length;e++)this.ships[e].setPosition(0===e?0:this.waveWidth*Math.random()-this.waveWidth/2,0,a+(0===e?0:this.waveWidth*Math.random())),this.ships[e].resetTraveling()}blowWaveAway(){for(let e of this.ships)e.traveling&&e.blowAway()}}const canvas=document.getElementById("renderCanvas"),engine=new BABYLON.Engine(canvas,!0),pather=new MazePather,mazes=[];for(let e=3;e<10;e++){let t=new Maze(e,0,BOTTOM_CENTER,TOP_CENTER);do{t.scrambleOffsets()}while(pather.solve(t).length>0);mazes.push(t)}const gameState={currentLevel:0,scene:void 0,xr:void 0,graphicalMaze:void 0,shipManager:void 0,timer:20,timestamp:new Date,timing:!1,cooling:!1,lost:!1,startLevelTimer:function(){this.timer=20,this.timestamp=new Date,this.timing=!0},endLevelTimer:function(){this.timing=!1},startCooldownTimer:function(){this.cooling=!0,this.timer=3},endCooldownTimer:function(){this.cooling=!1},endLevel:function(){this.endLevelTimer(),this.lost||(this.currentLevel===mazes.length-1&&(this.xr.baseExperience.exitXRAsync(),document.getElementById("screenText").innerText="You have defended Japan!"),this.currentLevel++,gameState.graphicalMaze.destroy(),this.startCooldownTimer(),this.shipManager.blowWaveAway())},startNextLevel:function(){this.startLevelTimer(),gameState.graphicalMaze=new GraphicalMaze(mazes[gameState.currentLevel],this.scene),gameState.graphicalMaze.origin.position.y=1,this.shipManager.startWave(20,3,10*(1+this.currentLevel))},decrementTimer:function(){let e=this.timestamp;this.timestamp=new Date;let t=(this.timestamp-e)/1e3;this.timing?(this.timer-=t,this.timer<=0&&(this.endLevelTimer(),this.lost=!0,this.xr.baseExperience.exitXRAsync(),document.getElementById("screenText").innerText="The Mongols succeed...")):this.cooling&&(this.timer-=t,this.timer<=0&&(this.endCooldownTimer(),this.startNextLevel()))}},createScene=async function(){let e=new BABYLON.Scene(engine);e.clearColor=new BABYLON.Color3(180/256,217/256,239/256),e.fogMode=BABYLON.Scene.FOGMODE_EXP,e.fogColor=new BABYLON.Color3(.9,.9,.85),e.fogDensity=.02;let t=new BABYLON.UniversalCamera("camera1",new BABYLON.Vector3(0,0,-.5),e);t.setTarget(BABYLON.Vector3.Zero()),t.attachControl(canvas,!0),new BABYLON.HemisphericLight("light",new BABYLON.Vector3(0,1,0),e).intensity=.7;let i=BABYLON.MeshBuilder.CreateGround("sea",{width:100,height:100}),a=new BABYLON.StandardMaterial("seaMat");a.diffuseColor=new BABYLON.Color3(0,0,1),i.material=a,i.position.y=-.001,i.position.z=50;let o=BABYLON.MeshBuilder.CreateGround("ground",{width:100,height:100}),n=new BABYLON.StandardMaterial("groundMat");n.diffuseColor=new BABYLON.Color3(0,1,0),o.material=n,o.position.y=.01,o.position.z=-50,gameState.scene=e,gameState.shipManager=new ShipManager(e,100,50),e.registerBeforeRender((()=>{gameState.decrementTimer()}));let r=await e.createDefaultXRExperienceAsync({pointerSelectionOptions:{preferredHandedness:"right",disableSwitchOnClick:!0}});gameState.xr=r,r.baseExperience.onStateChangedObservable.add((t=>{t===BABYLON.WebXRState.IN_XR&&(document.getElementById("screenText").innerText="",gameState.startLevelTimer(),gameState.shipManager.startWave(20,3,10*(1+gameState.currentLevel)),gameState.graphicalMaze=new GraphicalMaze(mazes[gameState.currentLevel],e),gameState.graphicalMaze.origin.position.y=1)}));let s=new BABYLON.Ray(new BABYLON.Vector3,new BABYLON.Vector3);return r.input.onControllerAddedObservable.add((t=>{"left"!==t.inputSource.handedness&&e.onPointerObservable.add((i=>{t.getWorldPointerRayToRef(s);let a=e.pickWithRay(s,(e=>e===gameState.graphicalMaze.pickingPlane));switch(i.type){case BABYLON.PointerEventTypes.POINTERDOWN:if(a.hit){let e=BABYLON.Vector3.Distance(a.pickedPoint,gameState.graphicalMaze.origin.position);gameState.graphicalMaze.initRotateLayer(e,a.pickedPoint)}break;case BABYLON.PointerEventTypes.POINTERMOVE:if(gameState.graphicalMaze.isSolved&&t.pointer.position.z>gameState.graphicalMaze.origin.position.z&&(gameState.endLevel(),pather.drawnPath.dispose()),a.hit)if(gameState.graphicalMaze.rotating)gameState.graphicalMaze.rotateLayer(a.pickedPoint);else{let e=BABYLON.Vector3.Distance(a.pickedPoint,gameState.graphicalMaze.origin.position);gameState.graphicalMaze.highlightLayer(e)}else gameState.graphicalMaze.unhightlightLayers(),gameState.graphicalMaze.endRotateLayer();break;case BABYLON.PointerEventTypes.POINTERUP:if(gameState.cooling)return;gameState.graphicalMaze.endRotateLayer(),gameState.graphicalMaze.unhightlightLayers(),mazes[gameState.currentLevel].setOffsets(gameState.graphicalMaze.offsets()),pather.solveAndShow(mazes[gameState.currentLevel]),pather.solution.length>0&&gameState.graphicalMaze.solved()}}))})),e},scene=createScene();engine.runRenderLoop((async function(){(await scene).render()})),window.addEventListener("resize",(function(){engine.resize()}))</script><div id=screenText>The Mongols approach...</div>