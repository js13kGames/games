<script src=/2023/webxr/babylon.js></script><style>body,html{margin:0;padding:0;width:100%;height:100%;font-size:0}body{margin:0;padding:0;width:100%;background-color:gray}canvas{height:100%}#wrapper{position:absolute}#app{margin:0 auto}canvas{position:absolute;top:0;left:0}</style><div id=app><div id=wrapper></div></div><script>(()=>{"use strict";const t=({max:t,min:e})=>Math.floor(Math.random()*(t-e))+e,e="#app",i="#wrapper",s=110,o=55,n=550,a=275,h=1760,r=880,l={title:{val:0,text:!0},playing:{val:1,text:!1},gameclear:{val:2,text:!0},gameover:{val:3,text:!0}},d=16,c=3;class m{constructor({x:t,y:e,height:i,width:s}){this.x=t,this.y=e,this.height=i,this.width=s,this.angle="u",this.prevAngle="u",this.color="yellow"}update(t){(t.keyboard.includes("r")||t.keyboard.includes("l"))&&this.updateAngle(t.keyboard),(t.keyboard.includes("u")||t.keyboard.includes("d"))&&(this.updateX(t.keyboard,t.stage.maxX,t.stage.minX,t),this.updateY(t.keyboard,t.stage.maxY,t.stage.minY,t)),t.stage.isInnerRoom(this.x,this.y,!0),t.stage.isInnerPath(this.x,this.y,this.angle,!0)}updateX(t,e,i,s){const o=this.x;"r"===this.angle&&t.includes("u")||"l"===this.angle&&t.includes("d")?this.x=this.x+1:("r"===this.angle&&t.includes("d")||"l"===this.angle&&t.includes("u"))&&(this.x=this.x-1),this.x>=e&&(this.x=e),this.x<=i&&(this.x=i),s.stage.hitWall(this.x,this.y)&&(this.x=o)}updateY(t,e,i,s){const o=this.y;"u"===this.angle&&t.includes("u")||"d"===this.angle&&t.includes("d")?this.y=this.y-1:("u"===this.angle&&t.includes("d")||"d"===this.angle&&t.includes("u"))&&(this.y=this.y+1),this.y>=e&&(this.y=e),this.y<=i&&(this.y=i),s.stage.hitWall(this.x,this.y)&&(this.y=o)}updateAngle(t){this.prevAngle=this.angle,t.includes("r")&&("u"===this.angle?this.angle="r":"r"===this.angle?this.angle="d":"d"===this.angle?this.angle="l":"l"===this.angle&&(this.angle="u")),t.includes("l")&&("u"===this.angle?this.angle="l":"r"===this.angle?this.angle="u":"d"===this.angle?this.angle="r":"l"===this.angle&&(this.angle="d"))}draw(t){this.drawCharacter(t.ctx)}drawCharacter(t){const e=this.x*d+this.width/2,i=this.y*d+this.width/2,s=this.width/2;let o=0;"r"===this.angle&&(o=90),"d"===this.angle&&(o=180),"l"===this.angle&&(o=270);const n=e-s*Math.cos((90+o)/180*Math.PI),a=i-s*Math.sin((90+o)/180*Math.PI),h=e-s*Math.cos((210+o)/180*Math.PI),r=i-s*Math.sin((210+o)/180*Math.PI),l=e-s*Math.cos((330+o)/180*Math.PI),c=i-s*Math.sin((330+o)/180*Math.PI);t.beginPath(),t.moveTo(n,a),t.lineTo(h,r),t.lineTo(l,c),t.closePath(),t.fillStyle=this.color,t.fill()}}class u extends m{constructor({x:t,y:e,height:i,width:s}){super({x:t,y:e,height:i,width:s}),this.color="red",this.speed=1,this.step=0,this.prevD=[]}update(e){let i=[["u"],["u","r"],["r"],["r","d"],["d"],["d","l"],["l"],["l","u"],[]],s=i[t({max:i.length-1,min:0})];this.step>0?(this.step-=1,s=this.prevD):(this.step=t({max:100,min:10}),this.prevD=s),this.updateX(s,e.stage.maxX,e.stage.minX,e),this.updateY(s,e.stage.maxY,e.stage.minY,e),this.updateAngle(s)}updateX(t,e,i,s){const o=this.x;t.find((t=>"r"===t))?this.x=this.x+1:t.find((t=>"l"===t))&&(this.x=this.x-1),this.x>=e&&(this.x=e),this.x<=i&&(this.x=i),s.stage.hitWall(this.x,this.y)&&(this.x=o)}updateY(t,e,i,s){const o=this.y;t.find((t=>"u"===t))&&(this.y=this.y-1),t.find((t=>"d"===t))&&(this.y=this.y+1),this.y>=e&&(this.y=e),this.y<=i&&(this.y=i),s.stage.hitWall(this.x,this.y)&&(this.y=o)}updateAngle(t){t.includes("r")||t.includes("l")||!t.includes("u")||t.includes("d")||(this.angle=0),t.includes("r")&&!t.includes("l")&&t.includes("u")&&!t.includes("d")&&(this.angle=45),!t.includes("r")||t.includes("l")||t.includes("u")||t.includes("d")||(this.angle=90),t.includes("r")&&!t.includes("l")&&!t.includes("u")&&t.includes("d")&&(this.angle=135),t.includes("r")||t.includes("l")||t.includes("u")||!t.includes("d")||(this.angle=180),!t.includes("r")&&t.includes("l")&&!t.includes("u")&&t.includes("d")&&(this.angle=225),t.includes("r")||!t.includes("l")||t.includes("u")||t.includes("d")||(this.angle=270),!t.includes("r")&&t.includes("l")&&t.includes("u")&&!t.includes("d")&&(this.angle=315)}draw(t){const e=t.stage.isInnerRoom(this.x,this.y),i=t.stage.isInnerPath(this.x,this.y,[]);(e&&e.visible||i&&i.visible)&&super.draw(t)}}class g{constructor(){this.divideX=t({max:5,min:2}),this.divideY=3,this.stageColor1="rgba(0, 0, 150, 1)",this.stageColor2="rgba(0, 0, 150, 0.5)",this.defaultVisible=!1,this.realms=[],this.connects=[],this.pathPositions=[],this.divide(),this.makeRoom(),this.makePath(),this.maxX=Math.max(...this.realms.map((t=>t.right)))-1,this.minX=Math.min(...this.realms.map((t=>t.left))),this.maxY=Math.max(...this.realms.map((t=>t.bottom)))-1,this.minY=Math.min(...this.realms.map((t=>t.top)))}divide(){let t,e,i,s;const o=new Array(this.divideX),n=new Array(this.divideY),a=r,l=h,c=Math.floor(a/d),m=Math.floor(l/d);for(t=0;t<this.divideX;t+=1)o[t]=0;for(t=0;t<this.divideY;t+=1)n[t]=0;for(s=this.divideX,t=s;t<m;t+=1)o[Math.floor(Math.random()*this.divideX)]+=1;for(s=this.divideY,t=s;t<c;t+=1)n[Math.floor(Math.random()*this.divideY)]+=1;let u=1,g=2;for(t=0;t<this.divideX;t+=1){for(e=0;e<this.divideY;e+=1)i={left:u,right:u+o[t],top:g,bottom:g+n[e],sizeX:o[t],sizeY:n[e],id:this.realms.length,connectID:[]},this.realms.push(Object.assign({},i)),g+=n[e];g=2,u+=o[t]}}makeRoom(){let e,i,s,o,n,a,h,r,l,d,c,m;i=0,s=0,o=0,h=0,r=0,m=0;const u=(t,e,i,s,o)=>(t.roomLeft=e,t.roomTop=i,t.roomSizeX=s,t.roomSizeY=o,t.roomRight=e+s-1,t.roomBottom=i+o-1,t.visible=this.defaultVisible,t.know=!1,t);for(e=0;e<this.realms.length;e++){const g=this.realms[e];if(g.sizeX*g.sizeY<25)this.realms[e]=u(g,g.left+2,g.top+2,g.sizeX-4,g.sizeY-4);else{for(i=0,c=!0;c;){if(i+=1,i>100){h=g.sizeX-4,r=g.sizeY-4;break}l=g.sizeX-4,d=g.sizeY-4,h=t({max:l,min:5}),r=t({max:d,min:5}),m=h*r/(g.sizeX*g.sizeY),c=!0,h*r<25&&(c=!1),m<.4&&(c=!1)}n=g.sizeX-h-4,s=n>0?t({max:n,min:2}):2,a=g.sizeY-r-4,o=a>0?t({max:a,min:2}):2,this.realms[e]=u(g,g.left+s,g.top+o,h,r)}}}makePath(){let t,e,i;for(t=0;t<this.realms.length;t+=1)e=this.getAdjacentRealmIndices(t),i=Math.floor(Math.random()*e.length),this.addConnect(this.realms[t],this.realms[e[i]]);for(const t of this.connects)this.drawConnect(null,t,!1)}makePathObject(t,e){let i=this.pathPositions.find((i=>i.x===t&&i.y===e));i||(i={x:t,y:e,visible:this.defaultVisible,know:!1},this.pathPositions.push(i))}addConnect(e,i){let s,o,n,a,h,r;if(this.connects.some((t=>t.fromId===e.id&&t.toId===i.id||t.fromId===i.id&&t.toId===e.id)))return;const l={fromId:e.id,toId:i.id},d=e=>t({max:e.roomBottom-2,min:e.roomTop+2}),c=e=>t({max:e.roomRight-2,min:e.roomLeft+2});e.left===i.right&&(s=e.roomLeft-1,o=d(e),n=i.roomRight+1,a=d(i),r=e.roomLeft-e.left,h=3),i.left===e.right&&(s=e.roomRight+1,o=d(e),n=i.roomLeft-1,a=d(i),r=e.right-e.roomRight,h=1),e.top===i.bottom&&(s=c(e),o=e.roomTop-1,n=c(i),a=i.roomBottom+1,r=e.roomTop-e.top,h=0),i.top===e.bottom&&(s=c(e),o=e.roomBottom+1,n=c(i),a=i.roomTop-1,r=e.bottom-e.roomBottom,h=2),l.startX=s,l.startY=o,l.endX=n,l.endY=a,l.middle=r,l.direction=h,this.connects.push(Object.assign({},l)),e.connectID.push(i.id),i.connectID.push(e.id)}getAdjacentRealmIndices(t){const e=[],i=this.realms[t];for(let s=0;s<this.realms.length;s+=1)t!==s&&this.isAdjacent(i,this.realms[s])&&e.push(s);return e}isAdjacent(t,e){if(t.left===e.right||e.left===t.right){if(t.top<=e.bottom&&t.top>=e.top)return!0;if(t.bottom>=e.top&&t.bottom<=e.bottom)return!0}if(t.top===e.bottom||e.top===t.bottom){if(t.left>=e.left&&t.left<=e.right)return!0;if(t.right>=e.left&&t.right<=e.right)return!0}return!1}update(t){for(const t of this.realms)t.visible=this.defaultVisible;for(const t of this.pathPositions)t.visible=!1}draw(t){this.drawScaleLine(t);for(const e of this.realms)this.drawRoom(t.ctx,e);for(const e of this.connects)this.drawConnect(t.ctx,e)}drawScaleLine(t){t.ctx.strokeStyle="rgba(250, 250, 250, 0.25)",t.ctx.lineWidth=1;const e=r,i=h,s=Math.floor(e/d),o=Math.floor(i/d);let n;for(n=0;n<=s;n+=1)t.ctx.beginPath(),t.ctx.moveTo(0,d*n),t.ctx.lineTo(i,d*n),t.ctx.stroke(),t.ctx.closePath();for(n=0;n<=o;n+=1)t.ctx.beginPath(),t.ctx.moveTo(d*n,0),t.ctx.lineTo(d*n,e),t.ctx.stroke(),t.ctx.closePath();t.ctx.strokeStyle="rgba(250, 250, 250, 1)",t.ctx.strokeRect(i,e,o*d,s*d)}drawRoom(t,e){t.lineWidth=2,t.strokeStyle=e.visible?this.stageColor1:this.stageColor2,t.fillStyle=e.visible?this.stageColor1:this.stageColor2,t.strokeRect(e.roomLeft*d,e.roomTop*d,e.roomSizeX*d,e.roomSizeY*d),(e.visible||e.know)&&t.fillRect(e.roomLeft*d,e.roomTop*d,e.roomSizeX*d,e.roomSizeY*d)}drawConnect(t,e,i=!0){var s,o,n,a,h;for(n=e.startX,a=e.startY,o=e.direction,h=e.middle,s=0;s<h;s+=1)i?this.drawPath(t,n,a):this.makePathObject(n,a),0===o&&(a-=1),1===o&&(n+=1),2===o&&(a+=1),3===o&&(n-=1);for(o%2==0?(h=Math.abs(e.startX-e.endX),e.startX>e.endX&&(o=3),e.startX<e.endX&&(o=1)):(h=Math.abs(e.startY-e.endY)+1,e.startY>e.endY&&(o=0),e.startY<e.endY&&(o=2)),s=0;s<h;s+=1)i?this.drawPath(t,n,a):this.makePathObject(n,a),s!==h-1&&(0===o&&(a-=1),1===o&&(n+=1),2===o&&(a+=1),3===o&&(n-=1));for(h=(o=e.direction)%2==0?Math.abs(a-e.endY):Math.abs(n-e.endX),s=0;s<h;s+=1)0===o&&(a-=1),1===o&&(n+=1),2===o&&(a+=1),3===o&&(n-=1),i?this.drawPath(t,n,a):this.makePathObject(n,a)}drawPath(t,e,i){const s=this.pathPositions.find((t=>t.x===e&&t.y===i));(s.visible||s.know)&&(t.fillStyle=s.visible?this.stageColor1:this.stageColor2,t.fillRect(d*e,d*i,d,d))}hitWall(t,e,i=["u"]){return!this.isInnerRoom(t,e)&&!this.isInnerPath(t,e,i)}isInnerRoom(t,e,i=!1){for(const s of this.realms)if(s.roomLeft<=t&&t<=s.roomRight&&s.roomTop<=e&&e<=s.roomBottom){if(i){s.visible=!0,s.know=!0;for(const t of this.pathPositions)t.x>=s.roomLeft-1&&t.x<=s.roomRight+1&&t.y>=s.roomTop-1&&t.y<=s.roomBottom+1&&(t.visible=!0,t.know=!0)}return s}return null}isInnerPath(t,e,i,s=!1){const o=i.length>0?i[0]:null,n=[];if("u"===o)for(let i=1;i<=c;i++)n.push({x:t,y:e-i});if("d"===o)for(let i=1;i<=c;i++)n.push({x:t,y:e+i});if("u"!==o&&"d"!==o||(n.push({x:t+1,y:e}),n.push({x:t-1,y:e})),"l"===o)for(let i=1;i<=c;i++)n.push({x:t-i,y:e});if("r"===o)for(let i=1;i<=c;i++)n.push({x:t+i,y:e});"l"!==o&&"r"!==o||(n.push({x:t,y:e+1}),n.push({x:t,y:e-1}));let a=null;for(const i of this.pathPositions)i.x===t&&i.y===e&&(s&&(i.visible=!0,i.know=!0),a=i),s&&n.some((t=>t.x===i.x&&t.y===i.y))&&(i.visible=!0,i.know=!0);return a}}class p{constructor(t){this.camera=new BABYLON.FreeCamera("camera",new BABYLON.Vector3(t.player.x,.5,o-t.player.y),t.scene),this.camera.rotation.y=0,new BABYLON.SpotLight("spotLight_main",new BABYLON.Vector3(0,5,0),new BABYLON.Vector3(0,-2,0),Math.PI,10,t.scene),this.light=new BABYLON.SpotLight("spotLight",new BABYLON.Vector3(t.player.x,2,o-t.player.y),new BABYLON.Vector3(0,-2,2),Math.PI/3,80,t.scene),this.light.diffuse=new BABYLON.Color3(1,1,1),this.light.specular=new BABYLON.Color3(1,1,1);const e=new BABYLON.StandardMaterial("m_ehead",t.scene);e.emissiveColor=new BABYLON.Color3(.99,.706,.443);const i=new BABYLON.StandardMaterial("m_ebody",t.scene);i.emissiveColor=new BABYLON.Color3(100,0,0),this.enemies=[];let s,n,a=0;for(const h of t.enemies)s=BABYLON.Mesh.CreateSphere("head"+a,32,.7,t.scene),s.position.y=1,s.material=e,n=BABYLON.Mesh.CreateCylinder("body"+a,2,0,1,24,1,t.scene),n.position.y=0,n.material=i,this.enemies[a]=BABYLON.Mesh.MergeMeshes([s,n],!0,!0,void 0,!1,!0),this.enemies[a].position.x=h.x,this.enemies[a].position.z=o-h.y,a++;const h=BABYLON.Mesh.CreateSphere("bhead",32,.7,t.scene);h.position.y=1,h.material=e;const r=new BABYLON.StandardMaterial("m_bbody",t.scene);r.emissiveColor=new BABYLON.Color3(1,.3,.3);const l=BABYLON.Mesh.CreateCylinder("bbody",2,0,1,24,1,t.scene);l.position.y=0,l.material=r,this.brother=BABYLON.Mesh.MergeMeshes([h,l],!0,!0,void 0,!1,!0),this.brother.position.x=t.brother.x,this.brother.position.z=o-t.brother.y}drawMap(t,e){let i,n,a;const l=new BABYLON.StandardMaterial("g-material",t.scene);let d,c;l.diffuseTexture=new BABYLON.Texture("floor.jpg",t.scene),l.diffuseTexture.uScale=h,l.diffuseTexture.vScale=r,l.specularColor=new BABYLON.Color3(.2,.2,.2),BABYLON.Mesh.CreateGround("ground",h,r,0,t.scene,!1).material=l;let m=!0;for(d=0;d<s;d++)for(c=0;c<o;c++)i=BABYLON.Mesh.CreateBox(`wall-${d}-${c}`,1,t.scene),i.position.x=d,i.position.z=c,i.material=l,n=BABYLON.Mesh.CreateBox(`wall-${d}-${c}-1`,1,t.scene),n.position.x=d,n.position.z=c,n.position.y=1,n.material=l,a=BABYLON.Mesh.CreateBox(`wall-${d}-${c}-2`,1,t.scene),a.position.x=d,a.position.z=c,a.position.y=2,i.material=l,m=!m;for(const s of e.realms)for(d=s.roomLeft;d<=s.roomRight;d++)for(c=s.roomTop;c<=s.roomBottom;c++)i=t.scene.getMeshByName(`wall-${d}-${o-c}`),i&&i.dispose(),n=t.scene.getMeshByName(`wall-${d}-${o-c}-1`),n&&n.dispose(),a=t.scene.getMeshByName(`wall-${d}-${o-c}-2`),a&&a.dispose();for({x:d,y:c}of e.pathPositions)i=t.scene.getMeshByName(`wall-${d}-${o-c}`),i&&i.dispose(),n=t.scene.getMeshByName(`wall-${d}-${o-c}-1`),n&&n.dispose()}update(t){"u"===t.player.angle?(this.camera.rotation.y=0,this.light.direction.z=2,this.light.direction.x=0):"r"===t.player.angle?(this.camera.rotation.y=Math.PI/2,this.light.direction.z=0,this.light.direction.x=2):"d"===t.player.angle?(this.camera.rotation.y=Math.PI,this.light.direction.z=-2,this.light.direction.x=0):"l"===t.player.angle&&(this.camera.rotation.y=Math.PI+Math.PI/2,this.light.direction.z=0,this.light.direction.x=-2),this.camera.position.x=t.player.x,this.camera.position.z=o-t.player.y,this.light.position.x=t.player.x,this.light.position.z=o-t.player.y;for(const e in this.enemies)this.enemies[e].position.x=t.enemies[e].x,this.enemies[e].position.z=o-t.enemies[e].y;this.brother.position.x=t.brother.x,this.brother.position.z=o-t.brother.y}draw(t){}}class x{constructor(){this.loadCount=0,this.gamemode=l.title,this.keyboard=[],this.canvasEl=void 0,this.ctx=void 0,this.displayCtx=void 0,this.stage=void 0,this.initialized=!1,this.prevTime=performance.now();const t=document.querySelector(e),s=document.querySelector(i);this._createCanvasEl(t,s,h,r),this.setKeyEvent(),this.initializeGame()}initializeGame(){this.stage=new g;const e=()=>{const e=this.stage.realms[t({max:this.stage.realms.length-1,min:0})];return[t({max:e.roomRight,min:e.roomLeft}),t({max:e.roomBottom,min:e.roomTop})]},[s,o]=e();this.player=new m({x:s,y:o,height:d,width:d});const n=t({max:10,min:3});let a,l;this.enemies=[];for(let t=0;t<n;t++)[a,l]=e(),this.enemies.push(new u({x:a,y:l,height:d,width:d}));const[c,x]=e();this.brother=new u({x:c,y:x,height:d,width:d}),this.stage.isInnerRoom(s,o,!0),this.stage.isInnerPath(s,o,["u"],!0);const y=document.querySelector(i);this.canvas3DEl&&y.removeChild(this.canvas3DEl),this.canvas3DEl=document.createElement("canvas"),[this.canvas3DEl.style.width,this.canvas3DEl.style.height]=[h,r],this.canvas3DEl.style.zIndex=0,y.appendChild(this.canvas3DEl),this.engine=new BABYLON.Engine(this.canvas3DEl),this.scene=new BABYLON.Scene(this.engine),this.scene.clearColor=new BABYLON.Color3(.659,.863,.925),this.threeDrawer=new p(this),this.threeDrawer.drawMap(this,this.stage),this.initialized=!0,this._draw()}setKeyEvent(){this.addKeyupEventListener(document,"keyup")}addKeyupEventListener(t,e,s=void 0){const o=t=>{const e=document.querySelector(i);if(this.textEl&&(e.removeChild(this.textEl),this.textEl=void 0),this.gamemode.text)return this.gamemode=l.playing,void(this.initialized||this.initializeGame());this.keyboard=[this._adjustKeyCode(t.code)],this._draw()};s?t.addEventListener(e,(()=>o(s))):t.addEventListener(e,o)}run(){this._draw()}_adjustKeyCode(t){const e={l:["ArrowLeft"],r:["ArrowRight"],u:["ArrowUp"],d:["ArrowDown"]};for(const[i,s]of Object.entries(e))if(s.includes(t))return i;return t}_createCanvasEl(t,e,i,s){const[o,h]=[i,s];let r=o;[t.style.width,t.style.height]=[`${r}px`,`${h}px`],this.canvasEl=document.createElement("canvas"),[this.canvasEl.width,this.canvasEl.height]=[o,h],this.ctx=this.canvasEl.getContext("2d");const l=document.createElement("canvas");[l.style.width,l.style.height]=[`${n}px`,`${a}px`],[l.width,l.height]=[o,h],l.style.zIndex=1,this.displayCtx=l.getContext("2d"),e.appendChild(l),this.canvas3DEl=document.createElement("canvas"),this.canvas3DEl.id="3dcanvas",[this.canvas3DEl.style.width,this.canvas3DEl.style.height]=[o,h],this.canvas3DEl.style.zIndex=0,e.appendChild(this.canvas3DEl)}_draw(){let t="";this.gamemode.val===l.title.val&&(t=[{text:"Run away from pied piper of Hamelin",size:16},{text:"",size:10},{text:"Rule: ",size:10},{text:"  You should find brother(Pink).",size:10},{text:"  If you are found by pied piper of hamelin(Red)...",size:10},{text:"Control: ",size:10},{text:"  Right/Left key: Change Direction",size:10},{text:"  Up Key: forward, Down Key: Back",size:10},{text:"",size:10},{text:"Press any key, You can start the game.",size:10}]),this.gamemode.val===l.gameclear.val&&(t=[{text:"Congratulations!!!",size:24},{text:"",size:10},{text:"You could help your brother and run away!!",size:10},{text:"",size:10},{text:"Press any key, You can restart the game.",size:10}]),this.gamemode.val===l.gameover.val&&(t=[{text:"Game over!!!",size:24},{text:"",size:10},{text:"You could not run away!!",size:10},{text:"",size:10},{text:"Press any key, You can restart the game.",size:10}]),this.gamemode.text?this.drawText(t):(this.update(),this.drawMap(),this.scene.render())}update(){this.stage.update(this),this.player.update(this);for(const t of this.enemies)t.update(this);this.brother.update(this),this.threeDrawer.update(this),this.enemies.some((t=>t.x===this.player.x&&t.y===this.player.y))&&(this.gamemode=l.gameover,this.initialized=!1,this._draw()),this.brother.x===this.player.x&&this.brother.y===this.player.y&&(this.gamemode=l.gameclear,this.initialized=!1,this._draw())}drawText(t){if(this.textEl)return;const e=document.querySelector(i);this.textEl=document.createElement("canvas"),[this.textEl.style.width,this.textEl.style.height]=[h,r],this.textEl.style.zIndex=9,e.appendChild(this.textEl);const s=this.textEl.getContext("2d");let o=30;for(const e of t)s.font=`${e.size}px serif`,s.fillStyle="rgba(200, 200, 200)",s.fillText(e.text,10,o),o+=e.size+1}drawMap(){this.ctx.save(),this.ctx.fillStyle="#205030",this.ctx.fillRect(0,0,h,r),this.stage.draw(this),this.brother.draw(this);for(const t of this.enemies)t.draw(this);this.player.draw(this),this.ctx.restore(),this.displayCtx.drawImage(this.canvasEl,0,0)}}class y extends x{constructor(t,i){const s=document.querySelector(e),o=document.createElement("button");[o.style.width,o.style.height]=["50px",`${i}px`],o.innerText="<<<",o.id="leftbtn",s.appendChild(o);const n=document.createElement("button");[n.style.width,n.style.height]=["50px",`${i}px`],n.innerText=">>>",n.id="rightbtn",s.appendChild(n);const a=document.createElement("button");[a.style.width,a.style.height]=["50px",`${i}px`],a.innerText="UP",a.id="upbtn",s.appendChild(a);const h=document.createElement("button");[h.style.width,h.style.height]=["50px",`${i}px`],h.innerText="DOWN",h.id="downbtn",s.appendChild(h),super(t,i)}setKeyEvent(){const t=document.querySelector("#leftbtn"),e=document.querySelector("#rightbtn"),i=document.querySelector("#upbtn"),s=document.querySelector("#downbtn");["mousedown","touchstart"].forEach((o=>{this.addKeydownEventListener(t,o,{code:"l"}),this.addKeydownEventListener(e,o,{code:"r"}),this.addKeydownEventListener(i,o,{code:"u"}),this.addKeydownEventListener(s,o,{code:"d"})}))}}const f=[],w=()=>{let t;t=navigator.userAgent.match(/iPhone|Android.+Mobile/)?new y:new x,t.run()},v=navigator.userAgent.toLowerCase(),b=v.indexOf("iphone")>-1,B=v.indexOf("ipad")>-1,Y=v.indexOf("android")>-1&&v.indexOf("mobile")>-1,z=v.indexOf("android")>-1&&-1==v.indexOf("mobile");(b||B)&&(window.onorientationchange=C),(Y||z)&&(window.onresize=C);const M=C();function C(){return 90==Math.abs(window.orientation)?"横向き":"縦向き"}if((b||B||Y||z)&&"縦向き"===M)document.getElementById("app").innerHTML="横向きにしてください";else{let t=0;0===f.length&&w();for(var L=0;L<f.length;++L)f[L].onload=function(){++t,t==f.length&&w()}}})()</script>