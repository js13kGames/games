<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"/> <meta name="viewport" content="width=device-width, initial-scale=1"/> <title>Schrödinger’s Catwalk</title> <style> :root{ --bg:#0c0b10; --ink:#f7f7fa; --accent:#ffd54a; --bad:#ff4a68; --good:#54e0a8; --muted:#9aa1ab; --luckyA:#9be7d5; --luckyB:#1ea07f; --unluckyA:#3a235a; --unluckyB:#1a112e; --divider:#ffffff; --shadow: 0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22); } *{box-sizing:border-box} html,body{height:100%;} body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,sans-serif;} .wrap{max-width:1080px;margin:0 auto;padding:16px;} header{display:flex;align-items:center;justify-content:space-between;margin:8px 0 12px 0;} .brand{display:flex;gap:12px;align-items:center} .logo{width:40px;height:40px;border-radius:12px;background:linear-gradient(135deg,var(--luckyA),var(--luckyB));position:relative;box-shadow:var(--shadow)} .logo:after{content:"";position:absolute;right:-4px;top:-4px;width:20px;height:20px;border-radius:6px;background:linear-gradient(135deg,var(--unluckyA),var(--unluckyB));border:2px solid #111} h1{font-size:20px;letter-spacing:.5px;margin:0} .controls{display:flex;gap:8px;align-items:center} .btn{background:#151423;border:1px solid #2a2740;color:var(--ink);padding:8px 12px;border-radius:12px;font-weight:800;cursor:pointer;box-shadow:var(--shadow);transition:transform .08s ease} .btn:hover{transform:translateY(-1px)} .btn--accent{background:var(--accent);color:#111;border-color:#ffd54a} .gameShell{position:relative;border-radius:16px;overflow:hidden;border:2px solid #2a2740;box-shadow:var(--shadow);background:#0f0e18} canvas{display:block;width:100%;height:auto;background:linear-gradient(90deg,var(--luckyA),var(--luckyB) 49.8%,var(--divider) 49.8%,var(--divider) 50.2%,var(--unluckyA) 50.2%,var(--unluckyB));image-rendering:pixelated} .hud{position:absolute;inset:0;pointer-events:none} .hudRow{position:absolute;left:16px;right:16px;top:12px;display:flex;justify-content:space-between;align-items:center;gap:8px} .pill{pointer-events:auto;background:#151423;border:1px solid #2a2740;padding:8px 10px;border-radius:999px;display:flex;align-items:center;gap:10px;font-weight:800} .pill.good{border-color:#206b55;color:var(--good)} .pill.bad{border-color:#5e1930;color:var(--bad)} .toast{position:absolute;left:50%;top:64px;transform:translateX(-50%);background:#111028;border:1px solid #2a2740;border-radius:12px;padding:10px 14px;font-weight:800;opacity:0;transition:opacity .25s ease,transform .25s ease} .toast.show{opacity:1;transform:translate(-50%,0)} .modal{position:fixed;inset:0;background:rgba(7,6,14,.65);display:none;align-items:center;justify-content:center;padding:16px} .modal.open{display:flex} .card{background:#0f0f1b;border:1px solid #2a2740;border-radius:16px;max-width:780px;width:100%;box-shadow:var(--shadow)} .card header{padding:14px 16px;border-bottom:1px solid #2a2740} .card .content{padding:16px;display:grid;gap:12px} .row{display:flex;gap:12px;align-items:center} label{opacity:.8} input[type=range]{width:160px} /* Glitch overlay */ .glitch{position:absolute;inset:0;pointer-events:none;mix-blend-mode:screen;opacity:0;transition:opacity .25s ease} .glitch.show{opacity:.9} /* Meta message */ .meta{position:absolute;right:12px;bottom:12px;opacity:.6;font-size:12px} .badge{background:#1a8a66;color:#031a14;border-radius:999px;padding:4px 8px;font-weight:800} /* Game Over Screen */ .game-over{position:absolute;inset:0;background:rgba(7,6,14,.85);display:none;flex-direction:column;align-items:center;justify-content:center;gap:16px;z-index:100} .game-over.show{display:flex} .game-over h2{font-size:48px;margin:0;color:var(--bad)} .game-over .score{font-size:32px;margin:0} .game-over .message{font-size:20px;margin:0;text-align:center;max-width:80%} .game-over .high-score{font-size:18px;color:var(--accent);margin:0} @media (prefers-reduced-motion: reduce){ .btn{transition:none} .toast{transition:none} } </style> </head> <body> <div class="wrap"> <header> <div class="brand"> <div class="logo" aria-hidden="true"></div> <h1>Schrödinger’s Catwalk</h1> </div> <div class="controls"> <button class="btn btn--accent" id="playBtn" aria-label="Play or Pause">Play</button> <button class="btn" id="photoBtn" aria-label="Photo Mode (toggle UI)">Photo</button> <button class="btn" id="settingsBtn" aria-label="Open Settings">Settings</button> </div> </header> <div class="gameShell" role="application" aria-label="Game canvas: two realities side-by-side. Use arrows/WASD to move and Space to jump."> <canvas id="game" width="1200" height="600"></canvas> <div class="hud" id="hud"> <div class="hudRow"> <div class="pill" id="scorePill">Score <span id="score">0</span></div> <div class="pill good" id="healthPill">Health <span id="health">100</span></div> <div class="pill" id="seedPill">Seed <span id="seedOut">—</span></div> </div> <div class="toast" id="toast">IS THE CAT ALIVE?</div> <canvas class="glitch" id="glitch" width="1200" height="600" aria-hidden="true"></canvas> <div class="meta"><span class="badge" id="modeBadge">NORMAL</span></div> </div> <!-- Game Over Screen --> <div class="game-over" id="gameOver"> <h2>GAME OVER</h2> <div class="score">Score: <span id="finalScore">0</span></div> <div class="high-score">High Score: <span id="highScore">0</span></div> <div class="message" id="gameOverMessage">The cat is neither alive nor dead... just disappointed.</div> <button class="btn btn--accent" id="restartBtn">Play Again</button> </div> </div> <div class="modal" id="settingsModal" aria-hidden="true" aria-label="Settings"> <div class="card"> <header><strong>Settings</strong></header> <div class="content"> <div class="row"> <label>Difficulty</label> <select id="diff"> <option value="0">Gentle</option> <option value="1" selected>Normal</option> <option value="2">Spicy</option> <option value="3">Quantum Chaos</option> </select> </div> <div class="row"> <label>Motion</label> <select id="motion"> <option value="1">Full</option> <option value="0">Reduce</option> </select> </div> <div class="row"> <label>Key: Jump</label> <select id="keyJump"> <option>Space</option><option>KeyW</option><option>ArrowUp</option> </select> </div> <div class="row"> <label>Key: Left/Right</label> <select id="keyLeft"><option>ArrowLeft</option><option>KeyA</option></select> <select id="keyRight"><option>ArrowRight</option><option>KeyD</option></select> </div> <div class="row"> <button class="btn btn--accent" id="saveSettings">Save</button> <button class="btn" id="closeSettings">Close</button> </div> </div> </div> </div> </div> <audio id="jumpSound" src="data:" preload="auto"></audio> <audio id="hurtSound" src="data:" preload="auto"></audio> <audio id="deathSound" src="data:" preload="auto"></audio> <audio id="collectSound" src="data:" preload="auto"></audio> <audio id="meowSound" src="data:" preload="auto"></audio> <script> (()=>{ const $ = sel => document.querySelector(sel); const clamp=(n,a,b)=>Math.max(a,Math.min(b,n)); const lerp=(a,b,t)=>a+(b-a)*t; const TAU=Math.PI*2; const sounds = { jump: $('#jumpSound'), hurt: $('#hurtSound'), death: $('#deathSound'), collect: $('#collectSound'), meow: $('#meowSound') }; function preloadAudio() { const audioElements = [ 'jumpSound', 'hurtSound', 'deathSound', 'collectSound', 'meowSound' ]; audioElements.forEach(id => { const audio = document.getElementById(id); audio.volume = 0.5; audio.load(); }); } preloadAudio(); function playSound(sound, volume = 1.0) { if (state.muted) return; const s = sounds[sound].cloneNode(); s.volume = volume; s.play().catch(e => console.log("Audio play failed:", e)); } function makeRNG(seed){ let t = seed >>> 0; return ()=>{ t += 0x6D2B79F5; let r = Math.imul(t ^ t>>>15, 1 | t); r ^= r + Math.imul(r ^ r>>>7, 61 | r); return ((r ^ r>>>14) >>> 0) / 4294967296; }; } const store={ get(k,def){ try{ const v=localStorage.getItem(k); return v?JSON.parse(v):def }catch{return def} }, set(k,v){ try{ localStorage.setItem(k,JSON.stringify(v)) }catch{} } }; const canvas = document.getElementById('game'); const ctx = canvas.getContext('2d'); const glitchCanvas = document.getElementById('glitch'); const gtx = glitchCanvas.getContext('2d'); function clear(ctx, w, h){ ctx.clearRect(0,0,w,h); } const W = canvas.width, H = canvas.height, MID = W/2; const state={ running:false, time:0, dt:0, acc:0, fixed:1/60, speed:260, gravity:2200, health:100, score:0, seed: Math.floor(Date.now()/86400000), rng: null, diff: 1, motion: 1, muted: false, observer:false, distance: 0, multiplier: 1, combo: 0, comboTime: 0, }; function applyDifficulty(){ const d=state.diff; state.speed = [220,260,300,340][d]; state.gravity = [2000,2200,2350,2600][d]; } const input={left:false,right:false,jump:false,jumpBuffered:false, any:false}; let bindings = store.get('keys',{jump:'Space', left:'ArrowLeft', right:'ArrowRight'}); function onKey(e,down){ const code=e.code; if(code===bindings.left) input.left=down; if(code===bindings.right) input.right=down; if(code===bindings.jump){ input.jump=down; if(down) input.jumpBuffered=true; } input.any = down || input.left||input.right||input.jump; if(!down && code==='KeyP') toggleRun(); } window.addEventListener('keydown',e=>onKey(e,true)); window.addEventListener('keyup',e=>onKey(e,false)); canvas.addEventListener('touchstart',e=>{ const t = e.changedTouches[0]; const x = t.clientX - canvas.getBoundingClientRect().left; if(x < MID*canvas.clientWidth/W) input.left=true; else input.right=true; input.jumpBuffered=true; input.jump=true; e.preventDefault(); },{passive:false}); canvas.addEventListener('touchend',()=>{ input.left=input.right=input.jump=false; }); class Cat{ constructor(){ this.x=200; this.y=H-160; this.w=46; this.h=34; this.vx=0; this.vy=0; this.grounded=false; this.coyote=0; this.buffer=0; this.facing=1; this.anim=0; this.qFlicker=0; this.tailAngle = 0; this.bodyBob = 0; this.blinkTimer = 0; this.blinkInterval = 3 + Math.random() * 4; this.meowTimer = 0; this.meowInterval = 5 + Math.random() * 10; } step(dt){ const targetVX = (input.right?180:0) - (input.left?120:0); this.vx = lerp(this.vx, targetVX, 0.2); this.x += this.vx*dt; this.vy += state.gravity*dt; this.y += this.vy*dt; this.x = clamp(this.x, 60, MID-60); if(this.grounded) { this.coyote = 0.1; } else { this.coyote = Math.max(0,this.coyote-dt); } if(this.buffer>0) this.buffer=Math.max(0,this.buffer-dt); if(input.jumpBuffered){ this.buffer=0.12; input.jumpBuffered=false; } if(!input.jump && this.vy< -220) this.vy = -220; this.anim += dt*10; this.qFlicker = Math.max(0,this.qFlicker-dt); this.tailAngle = Math.sin(this.anim * 0.5) * 0.3; if (Math.abs(this.vx) > 10) { this.bodyBob = Math.sin(this.anim * 0.8) * 3; } else { this.bodyBob = lerp(this.bodyBob, 0, 0.1); } this.blinkTimer += dt; if (this.blinkTimer > this.blinkInterval) { this.blinkTimer = 0; this.blinkInterval = 3 + Math.random() * 4; } this.meowTimer += dt; if (this.meowTimer > this.meowInterval && this.grounded && state.running) { this.meowTimer = 0; this.meowInterval = 5 + Math.random() * 10; playSound('meow', 0.3); } if(this.y > H + 100) { changeHealth(-100); return; } } tryJump(){ const lie = state.rng() < 0.08 + state.diff*0.02; if((this.grounded||this.coyote>0||onWall(this)) && this.buffer>0){ this.buffer=0; this.grounded=false; if(lie){ toast("Button says JUMP, does FALL.", true); this.vy = 900; playSound('hurt', 0.7); } else { this.vy = -720; this.bodyBob = -6; playSound('jump', 0.5); } } } draw(ctx, side){ const x = side===0 ? this.x : MID + (MID-this.x-this.w); const y = this.y + this.bodyBob; const isBlinking = this.blinkTimer > 2.8 && this.blinkTimer < 3.2; ctx.fillStyle = side === 0 ? '#8c7853' : '#5a4a32'; ctx.beginPath(); ctx.ellipse(x + this.w/2, y + this.h/2 + 2, this.w/2, this.h/2, 0, 0, TAU); ctx.fill(); ctx.strokeStyle = side === 0 ? '#a6906b' : '#6a5a42'; ctx.lineWidth = 1; for (let i = 0; i < 8; i++) { const angle = Math.random() * TAU; const length = 5 + Math.random() * 5; const startX = x + this.w/2 + Math.cos(angle) * (this.w/2 - 2); const startY = y + this.h/2 + Math.sin(angle) * (this.h/2 - 2); const endX = startX + Math.cos(angle) * length; const endY = startY + Math.sin(angle) * length; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke(); } ctx.fillStyle = side === 0 ? '#6a5a42' : '#4a3a22'; ctx.beginPath(); ctx.moveTo(x + 10, y + 5); ctx.lineTo(x + 5, y - 5); ctx.lineTo(x + 15, y + 2); ctx.fill(); ctx.beginPath(); ctx.moveTo(x + this.w - 10, y + 5); ctx.lineTo(x + this.w - 5, y - 5); ctx.lineTo(x + this.w - 15, y + 2); ctx.fill(); ctx.fillStyle = side === 0 ? '#d4a5a5' : '#b48585'; ctx.beginPath(); ctx.moveTo(x + 10, y + 3); ctx.lineTo(x + 7, y - 2); ctx.lineTo(x + 13, y + 1); ctx.fill(); ctx.beginPath(); ctx.moveTo(x + this.w - 10, y + 3); ctx.lineTo(x + this.w - 7, y - 2); ctx.lineTo(x + this.w - 13, y + 1); ctx.fill(); ctx.strokeStyle = side === 0 ? '#6a5a42' : '#4a3a22'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(x + this.w - 5, y + this.h - 5); const tailX = x + this.w + 15 + Math.sin(this.tailAngle) * 8; const tailY = y + this.h - 15 + Math.cos(this.tailAngle) * 5; ctx.quadraticCurveTo(x + this.w + 5, y + this.h - 10, tailX, tailY); ctx.stroke(); ctx.fillStyle = side === 0 ? '#ffd54a' : '#ffaa33'; if (!isBlinking) { ctx.beginPath(); ctx.ellipse(x + 15, y + 12, 4, 6, 0, 0, TAU); ctx.fill(); ctx.beginPath(); ctx.ellipse(x + this.w - 15, y + 12, 4, 6, 0, 0, TAU); ctx.fill(); ctx.fillStyle = '#1a112e'; ctx.beginPath(); ctx.ellipse(x + 15 + (this.facing * 1.5), y + 12, 2, 2, 0, 0, TAU); ctx.fill(); ctx.beginPath(); ctx.ellipse(x + this.w - 15 + (this.facing * 1.5), y + 12, 2, 2, 0, 0, TAU); ctx.fill(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(x + 14 + (this.facing * 1.5), y + 11, 1, 1, 0, 0, TAU); ctx.fill(); ctx.beginPath(); ctx.ellipse(x + this.w - 16 + (this.facing * 1.5), y + 11, 1, 1, 0, 0, TAU); ctx.fill(); } else { ctx.fillStyle = '#1a112e'; ctx.fillRect(x + 11, y + 11, 8, 2); ctx.fillRect(x + this.w - 19, y + 11, 8, 2); } ctx.fillStyle = side === 0 ? '#ff758d' : '#e6647c'; ctx.beginPath(); ctx.ellipse(x + this.w/2, y + 18, 3, 2, 0, 0, TAU); ctx.fill(); ctx.strokeStyle = side === 0 ? '#ff758d' : '#e6647c'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(x + this.w/2, y + 20); ctx.lineTo(x + this.w/2, y + 22); ctx.stroke(); ctx.strokeStyle = side === 0 ? '#f7f7fa' : '#d7d7da'; ctx.lineWidth = 1; ctx.beginPath(); for (let i = 0; i < 3; i++) { ctx.moveTo(x + 5, y + 18 + i*3); ctx.lineTo(x - 5, y + 16 + i*3); ctx.moveTo(x + this.w - 5, y + 18 + i*3); ctx.lineTo(x + this.w + 5, y + 16 + i*3); } ctx.stroke(); if(this.qFlicker>0){ ctx.strokeStyle = state.time%0.1<0.05?'#ff4a68':'#54e0a8'; ctx.lineWidth = 2; ctx.beginPath(); ctx.ellipse(x + this.w/2, y + this.h/2, this.w/2 + 2, this.h/2 + 2, 0, 0, TAU); ctx.stroke(); } } } function onWall(cat){ return (cat.x<=60 || cat.x>=MID-60); } class Rect{ constructor(x,y,w,h,t){ this.x=x;this.y=y;this.w=w;this.h=h;this.t=t } } class Level{ constructor(){ this.segs=[]; this.haz=[]; this.pick=[]; this.npc=[]; this.scroll=0; this.pool=[]; this.biome = 0; this.biomeTimer = 0; } reset(){ this.segs.length=this.haz.length=this.pick.length=this.npc.length=0; this.scroll=0; this.biome = 0; this.biomeTimer = 0; } spawnChunk(){ const r = state.rng; const baseY = lerp(H*0.62,H*0.82,r()); const count = 3 + Math.floor(r()*3); let x=W + 40; let platType = 'plat'; if (this.biome === 1) platType = 'cloud'; if (this.biome === 2) platType = 'tech'; for(let i=0;i<count;i++){ const w=120 + r()*160; const gap= 80 + r()*140 - state.diff*10; const y = clamp(baseY + Math.sin(state.time*0.5 + i)*22 + (r()-0.5)*40, H*0.45, H*0.86); this.segs.push(new Rect(x,y,w,18,platType)); if(r()<0.55){ const pickupType = r() < 0.7 ? 'fish' : (r() < 0.85 ? 'star' : 'clock'); this.pick.push(new Rect(x+20+r()*(w-40), y-24, 16,16,pickupType)); } if(r()<0.38 + state.diff*0.06){ const hazardType = r() < 0.7 ? 'spike' : (r() < 0.85 ? 'ghost' : 'laser'); this.haz.push(new Rect(x+20+r()*(w-60), y-14, 22,22,hazardType)); } if(r()<0.18){ const npcType = r() < 0.7 ? 'human' : (r() < 0.85 ? 'scientist' : 'dog'); this.npc.push(new Rect(x+w*0.5, y-28, 22,32,npcType)); } x += w + gap; } } step(dt){ const s = state.speed*dt; this.scroll += s; state.distance += s; if(this.y > H + 100) { changeHealth(-100); return; } const all=[this.segs,this.haz,this.pick,this.npc]; for(const arr of all){ for(const it of arr){ it.x -= s; } } for(const arr of all){ while(arr.length && arr[0].x+arr[0].w < -40) arr.shift(); } if(this.segs.length<6) this.spawnChunk(); this.biomeTimer += dt; if (this.biomeTimer > 20) { this.biomeTimer = 0; this.biome = (this.biome + 1) % 3; } if (state.comboTime > 0) { state.comboTime -= dt; if (state.comboTime <= 0) { state.combo = 0; state.multiplier = 1; toast('Combo lost!', true); } } } collideCat(cat){ cat.grounded=false; for(const p of this.segs){ const cx=cat.x+cat.w*0.5, cy=cat.y+cat.h; if(cx>p.x && cx<p.x+p.w && cy>p.y && cy<p.y+30 && cat.vy>=0){ cat.y = p.y - cat.h; cat.vy=0; cat.grounded=true; if(state.rng()<0.08+state.diff*0.02 && p.t !== 'cloud'){ cat.qFlicker=0.25; } } } for(let i=0;i<this.pick.length;i++){ const f=this.pick[i]; if(rectHit(cat,f)){ let points = 0; let healthChange = 0; let message = ''; switch(f.t) { case 'fish': if(state.rng()<0.82){ healthChange = +8; points = 20; message = 'Fishbone +20'; playSound('collect', 0.5); } else { healthChange = -12; message = 'Rotten fish! -12'; playSound('hurt', 0.4); } break; case 'star': points = 50; state.combo++; state.comboTime = 5; state.multiplier = Math.min(5, 1 + state.combo * 0.2); message = `Star! x${state.multiplier.toFixed(1)}`; playSound('collect', 0.6); break; case 'clock': state.comboTime += 5; message = 'Time extended!'; playSound('collect', 0.4); break; } if (points > 0) { const totalPoints = Math.floor(points * state.multiplier); score(totalPoints); toast(`${message} ${totalPoints}`, false); } if (healthChange !== 0) { changeHealth(healthChange); } this.pick.splice(i,1); i--; continue; } } for(let i=0;i<this.haz.length;i++){ const h=this.haz[i]; if(rectHit(cat,h)){ const damage = -20 - state.diff*6; changeHealth(damage); cat.vy = -420; cat.grounded=false; toast(`${h.t === 'spike' ? 'Spike!' : h.t === 'ghost' ? 'Ghost!' : 'Laser!'}`,true); playSound('hurt', 0.8); this.haz.splice(i,1); i--; } } for(const n of this.npc){ if(Math.abs((cat.x+cat.w*0.5)-(n.x+n.w*0.5))<28 && Math.abs(cat.y-n.y)<30){ if(state.rng()<0.5){ changeHealth(+6); score(10); toast(n.t === 'human' ? 'Pet +6' : n.t === 'scientist' ? 'Experiment +6' : 'Dog +6',false); playSound('collect', 0.3); } else { changeHealth(-10); cat.vx -= 160; toast(n.t === 'human' ? 'Chased -10' : n.t === 'scientist' ? 'Shocked -10' : 'Bitten -10',true); playSound('hurt', 0.6); } } } } draw(ctx){ for(const p of this.segs){ if (p.t === 'plat') { ctx.fillStyle = '#1bdaac'; } else if (p.t === 'cloud') { ctx.fillStyle = '#f0f0ff'; } else { ctx.fillStyle = '#6b5b95'; } ctx.fillRect(p.x, p.y, p.w, p.h); if (p.t === 'plat') { ctx.fillStyle = '#0fa385'; ctx.fillRect(p.x, p.y, p.w, 4); } else if (p.t === 'cloud') { ctx.fillStyle = '#d0d0ff'; for (let i = 0; i < p.w; i += 15) { ctx.beginPath(); ctx.arc(p.x + i, p.y, 6, 0, TAU); ctx.fill(); } } else { ctx.fillStyle = '#524a6b'; for (let i = 0; i < p.w; i += 12) { ctx.fillRect(p.x + i, p.y, 4, 4); } } } for(const p of this.segs){ const mx = MID + (MID - (p.x+p.w)); if (p.t === 'plat') { ctx.fillStyle = '#4a2c7e'; } else if (p.t === 'cloud') { ctx.fillStyle = '#a0a0c0'; } else { ctx.fillStyle = '#3a2c55'; } ctx.fillRect(mx, p.y, p.w, p.h); if (p.t === 'plat') { ctx.fillStyle = '#3a1c6e'; ctx.fillRect(mx, p.y, p.w, 4); } else if (p.t === 'cloud') { ctx.fillStyle = '#8080a0'; for (let i = 0; i < p.w; i += 15) { ctx.beginPath(); ctx.arc(mx + i, p.y, 6, 0, TAU); ctx.fill(); } } else { ctx.fillStyle = '#2a1c45'; for (let i = 0; i < p.w; i += 12) { ctx.fillRect(mx + i, p.y, 4, 4); } } } for(const h of this.haz){ drawHazard(ctx, h.x, h.y, h.t); drawHazard(ctx, MID + (MID-(h.x+h.w)), h.y, h.t, true); } for(const f of this.pick){ drawPickup(ctx, f.x, f.y, f.t); drawPickup(ctx, MID + (MID-(f.x+f.w)), f.y, f.t, true); } for(const n of this.npc){ drawNPC(ctx, n.x, n.y, n.t); drawNPC(ctx, MID + (MID-(n.x+n.w)), n.y, n.t, true); } } } function rectHit(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h>b.y } function drawHazard(ctx,x,y,type,mirror=false){ switch(type) { case 'spike': ctx.fillStyle= mirror?'#c43b5a':'#ff758d'; ctx.beginPath(); for(let i=0;i<3;i++){ ctx.moveTo(x+i*8,y+22); ctx.lineTo(x+4+i*8,y); ctx.lineTo(x+8+i*8,y+22); } ctx.fill(); break; case 'ghost': ctx.fillStyle= mirror?'#7d5bbe':'#9d7bde'; ctx.beginPath(); ctx.arc(x+11, y+11, 10, 0, TAU); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(x+7, y+8, 2, 0, TAU); ctx.arc(x+15, y+8, 2, 0, TAU); ctx.fill(); break; case 'laser': ctx.fillStyle= mirror?'#ff3355':'#ff5577'; ctx.fillRect(x, y, 22, 4); ctx.fillStyle = '#333'; ctx.fillRect(x, y+4, 22, 8); break; } } function drawPickup(ctx,x,y,type,mirror=false){ switch(type) { case 'fish': ctx.fillStyle= mirror?'#b2b8c6':'#ffffff'; ctx.fillRect(x,y,16,10); ctx.fillStyle='#2b2e3a'; ctx.fillRect(x+2,y+4,2,2); ctx.fillRect(x+12,y+2,4,6); break; case 'star': ctx.fillStyle= mirror?'#ffcc44':'#ffdd66'; ctx.beginPath(); for (let i = 0; i < 5; i++) { ctx.lineTo( x + 8 + 8 * Math.cos((TAU * i)/5 - TAU/4), y + 8 + 8 * Math.sin((TAU * i)/5 - TAU/4) ); ctx.lineTo( x + 8 + 4 * Math.cos((TAU * i)/5 - TAU/4 + TAU/10), y + 8 + 4 * Math.sin((TAU * i)/5 - TAU/4 + TAU/10) ); } ctx.closePath(); ctx.fill(); break; case 'clock': ctx.fillStyle= mirror?'#44ccff':'#66ddff'; ctx.beginPath(); ctx.arc(x+8, y+8, 8, 0, TAU); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillRect(x+7, y+4, 2, 5); ctx.fillRect(x+7, y+7, 5, 2); break; } } function drawNPC(ctx,x,y,type,mirror=false){ switch(type) { case 'human': ctx.fillStyle= mirror?'#f08c3c':'#ffb36b'; ctx.fillRect(x,y,22,28); ctx.fillStyle='#2b2e3a'; ctx.fillRect(x+4,y-8,14,12); break; case 'scientist': ctx.fillStyle= mirror?'#3c8cf0':'#5cadff'; ctx.fillRect(x,y,22,28); ctx.fillStyle = '#fff'; ctx.fillRect(x+5, y+10, 12, 18); ctx.fillStyle = '#2b2e3a'; ctx.fillRect(x+4, y-6, 14, 8); break; case 'dog': ctx.fillStyle= mirror?'#8c5c2c':'#ac7c4c'; ctx.fillRect(x+5, y+15, 12, 13); ctx.fillRect(x+2, y+5, 18, 10); ctx.fillRect(x, y, 6, 6); ctx.fillRect(x+16, y, 6, 6); ctx.fillRect(x+15, y+25, 8, 4); break; } } const scoreOut = document.getElementById('score'); const healthOut= document.getElementById('health'); const toastEl = document.getElementById('toast'); const seedOut = document.getElementById('seedOut'); const glitchEl = document.getElementById('glitch'); const hud = document.getElementById('hud'); const gameOverEl = document.getElementById('gameOver'); const finalScoreEl = document.getElementById('finalScore'); const highScoreEl = document.getElementById('highScore'); const gameOverMessageEl = document.getElementById('gameOverMessage'); const mockingMessages = [ "The cat is neither alive nor dead... just disappointed.", "Schrödinger would be confused by your performance.", "Maybe quantum mechanics isn't your strong suit.", "The cat has used up its 9 lives... and then some.", "Reality has collapsed. And not in a good way.", "You've observed the worst possible outcome.", "The cat has decided to find a new owner.", "Quantum superposition has never been so disappointing.", "Even in a parallel universe, you failed.", "The cat has filed a formal complaint." ]; function score(n){ state.score += n; scoreOut.textContent = state.score; if (state.multiplier > 1) { scoreOut.style.color = '#ffdd00'; } else { scoreOut.style.color = ''; } } function changeHealth(n){ state.health = clamp(state.health + n, 0, 120); healthOut.textContent = state.health; if (state.health < 30) { healthOut.style.color = '#ff4a68'; } else if (state.health < 70) { healthOut.style.color = '#ffd54a'; } else { healthOut.style.color = '#54e0a8'; } if(state.health<=0) gameOver(); } function toast(msg,bad){ toastEl.textContent = msg; toastEl.classList.add('show'); if(bad){ toastEl.style.borderColor='#5e1930'; toastEl.style.color='#ff4a68'; } else { toastEl.style.borderColor='#206b55'; toastEl.style.color='#54e0a8'; } clearTimeout(toastEl._t); toastEl._t=setTimeout(()=>toastEl.classList.remove('show'),1200); } function glitch(){ const a = glitchEl; const c = gtx; c.clearRect(0,0,W,H); for(let y=0;y<H;y+=8){ const alpha = Math.random()*0.12; c.fillStyle = `rgba(255,255,255,${alpha})`; c.fillRect(0,y,W,4); } a.classList.add('show'); setTimeout(()=>a.classList.remove('show'),250); } function uiLie(){ const real=state.score; const fake=real + 250 + Math.floor(state.rng()*250); scoreOut.textContent = fake + ' ?'; setTimeout(()=> scoreOut.textContent = state.score, 2000); } const cat = new Cat(); const level = new Level(); function reset(seed){ state.seed = seed ?? state.seed; state.rng = makeRNG(state.seed); state.score=0; state.health=100; state.time=0.1; state.distance=0; state.multiplier=1; state.combo=0; state.comboTime=0; level.reset(); cat.x=50; cat.y=H-500; cat.vx=0; cat.vy=0; cat.grounded=false; cat.qFlicker=0; seedOut.textContent = state.seed; for(let i=0;i<3;i++) level.spawnChunk(); scoreOut.style.color = ''; healthOut.style.color = '#54e0a8'; gameOverEl.classList.remove('show'); } function step(dt){ state.time += dt; level.step(dt); cat.step(dt); cat.tryJump(); level.collideCat(cat); if (state.running) { const distancePoints = Math.floor(state.speed * dt * 0.1); score(distancePoints); } if(state.rng()<0.004 + state.diff*0.002) glitch(); if(state.rng()<0.003) uiLie(); if(state.rng()<0.002 && state.observer) toast(`Odds: lie ${(8+state.diff*2)}%`, false); if(state.time%5<dt && state.health>0 && state.health < 100) changeHealth(+0.5); if(state.time%20<dt) state.speed += 8 + state.diff*2; } function render(){ clear(ctx,W,H); level.draw(ctx); cat.draw(ctx,0); cat.draw(ctx,1); if (state.comboTime > 0) { ctx.fillStyle = '#ffdd00'; ctx.font = '16px system-ui'; ctx.textAlign = 'center'; ctx.fillText(`COMBO x${state.multiplier.toFixed(1)}`, MID, 40); } } let last=0; function frame(t){ if(!state.running){ last=t; return requestAnimationFrame(frame); } const elapsed = (t-last)/1000; last=t; state.acc+=elapsed; const cap=0.25; state.acc=Math.min(state.acc,cap); while(state.acc>=state.fixed){ step(state.fixed); state.acc-=state.fixed; } render(); requestAnimationFrame(frame); } function toggleRun(){ state.running = !state.running; $('#playBtn').textContent = state.running?'Pause':'Play'; if(state.running) { toast('Run!',false); if (state.health <= 0) { reset(); } } } function gameOver(){ state.running=false; playSound('death', 0.8); const highScore = store.get('highScore', 0); if (state.score > highScore) { store.set('highScore', state.score); toast(`New High Score: ${state.score}!`, false); } finalScoreEl.textContent = state.score; highScoreEl.textContent = Math.max(state.score, highScore); const randomMessage = mockingMessages[Math.floor(Math.random() * mockingMessages.length)]; gameOverMessageEl.textContent = randomMessage; gameOverEl.classList.add('show'); $('#playBtn').textContent='Play Again'; cat.qFlicker=0.6; state.health = 100; } const modal=$('#settingsModal'); function openSettings(){ modal.classList.add('open'); modal.setAttribute('aria-hidden','false'); } function closeSettings(){ modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); } $('#settingsBtn').addEventListener('click',openSettings); $('#closeSettings').addEventListener('click',closeSettings); $('#saveSettings').addEventListener('click',()=>{ state.diff = +$('#diff').value; state.motion = +$('#motion').value; bindings={ jump: $('#keyJump').value, left: $('#keyLeft').value, right: $('#keyRight').value }; store.set('keys',bindings); store.set('settings',{diff:state.diff,motion:state.motion}); applyDifficulty(); toast('Settings saved',false); closeSettings(); }); $('#photoBtn').addEventListener('click',()=>{ hud.style.display = hud.style.display==='none' ? 'block':'none'; }); $('#playBtn').addEventListener('click',()=> toggleRun()); $('#restartBtn').addEventListener('click',()=> { reset(); healthOut.style.color = '#54e0a8'; toggleRun(); }); (function init(){ const s=store.get('settings'); if(s){ state.diff=s.diff; state.motion=s.motion; $('#diff').value=state.diff; $('#motion').value=state.motion; } applyDifficulty(); reset(state.seed); requestAnimationFrame(frame); })(); const secret=['ArrowUp','ArrowUp','ArrowDown','ArrowDown','ArrowLeft','ArrowRight','ArrowLeft','ArrowRight','KeyB','KeyA']; const buf=[]; window.addEventListener('keydown',e=>{ buf.push(e.code); if(buf.length>secret.length) buf.shift(); if(secret.every((k,i)=>buf[i]===k)){ state.observer=!state.observer; $('#modeBadge').textContent=state.observer?'OBSERVER':'NORMAL'; toast(state.observer?'Observer Mode':'Normal Mode',false); }}); })(); </script> </body> </html>