<body><script>!function(t){var e={};function r(o){if(e[o])return e[o].exports;var i=e[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,r),i.l=!0,i.exports}r.m=t,r.c=e,r.d=function(t,e,o){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(o,i,function(e){return t[e]}.bind(null,i));return o},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=3)}([function(t,e,r){"use strict";const o=r(1);let i=+localStorage.getItem("recordScore")||0;t.exports=class{constructor(){this.camera={},this.cable=[];let t=document.createElement("style");t.innerHTML="* {margin: 0; padding: 0; overflow: hidden;} html, body {width: 100%; height: 100%;}",document.body.appendChild(t),this.width=document.body.offsetWidth,this.height=document.body.offsetHeight,this.clearState(),this.initKeyboard(),this.initCanvas(),this.initDrawer(),this.initScore(),this.initCenterEl(),this.start()}clearState(){this.camera.x=0,this.camera.y=0,this.trees=[],this.area={},this.score=0,this.cable.length=0,this.cable.push({x:0,y:-this.height/2}),this.cable.push({x:0,y:0})}initScore(){let t=document.createElement("div"),e=t.style;e.top="10px",e.left="10px",e.fontSize="18px",e.fontFamily="Arial",e.fontWeight="bold",e.position="absolute",e.color="white",document.body.appendChild(t),this.scoreEl=t}start(){this.interval=setInterval((()=>{this.main()}),30)}stop(){clearInterval(this.interval)}restart(){this.stop(),this.clearState(),this.start()}main(){let{camera:t,keyCodes:e}=this,r=10,o=0,n=1;if(e.up&&(n=1,r=30),e.down&&(n=-1),e.left&&(o=-1),e.right&&(o=1),0!=o||0!=n){let e=Math.sqrt(o*o+n*n),a=t.x+r*o/e,s=t.y+r*n/e;if(this.trees.some((t=>{let e=a-t.x,r=s-t.y;return Math.sqrt(e*e+r*r)<25})))return this.stop(),void(this.score>i?(i=this.score,localStorage.setItem("recordScore",i),this.showRecord((()=>{this.clearState(),this.start()}))):this.showGameOver((()=>{this.clearState(),this.start()})));t.x=a,t.y=s;let l=this.cable.slice(-1)[0];l.x==a||l.y==s?(l.x=a,l.y=s):this.cable.push({x:a,y:s}),this.score+=e}this.generateArea(),this.draw()}initCanvas(){const t=document.createElement("canvas");t.style.position="fixed",t.style.width="100%",t.style.height="100%",document.body.appendChild(t),this.canvas=t}initDrawer(){this.drawer=new o(this.canvas)}initKeyboard(){let t={up:!1,down:!1,left:!1,right:!1};this.keyCodes=t,document.onkeyup=e=>{37==e.keyCode&&(t.left=!1),38==e.keyCode&&(t.up=!1),39==e.keyCode&&(t.right=!1),40==e.keyCode&&(t.down=!1)},document.onkeydown=e=>{37==e.keyCode&&(t.left=!0),38==e.keyCode&&(t.up=!0),39==e.keyCode&&(t.right=!0),40==e.keyCode&&(t.down=!0)}}draw(){this.drawer.draw(this),this.drawScore()}drawScore(){this.scoreEl.innerHTML=Math.floor(this.score)}generateArea(){this.trees=[];let{camera:t,width:e,height:r,area:o}=this;for(let i=t.x-e/2;i<t.x+e/2;i+=175)for(let e=t.y-r/2;e<t.y+r/2;e+=175){let t=i-i%175,n=e-e%175,a=t+":"+n,s=o[a];t>=-175&&t<=175&&n<=r/4&&n>=-r/2||(s||(s={x:t+10+165*Math.random(),y:n+10+165*Math.random()},o[a]=s),this.trees.push(s))}}initCenterEl(){let t=document.createElement("div"),e=t.style;e.top="calc( 50% - 10px )",e.left="10px",e.width="100%",e.fontSize="36px",e.fontFamily="Arial",e.fontWeight="bold",e.position="absolute",e.color="white",e.opacity="1",e.textAlign="center",e.transition="all .5s",document.body.appendChild(t),this.centerEl=t}showRecord(t){clearTimeout(this.timer),this.centerEl.innerHTML="RECORD: "+Math.floor(i),this.centerEl.style.opacity=1,this.timer=setTimeout((()=>{this.centerEl.style.opacity=0,this.timer=setTimeout((()=>{this.centerEl.innerHTML="",t&&t()}),2e3)}),2e3)}showGameOver(t){clearTimeout(this.timer),this.centerEl.innerHTML="OFFLINE",this.centerEl.style.opacity=1,this.timer=setTimeout((()=>{this.centerEl.style.opacity=0,this.timer=setTimeout((()=>{this.centerEl.innerHTML="",t&&t()}),1e3)}),1e3)}}},function(t,e,r){"use strict";const o=r(2);t.exports=class{constructor(t){let e=t.getContext("webgl");this.gl=e,this.canvas=t,this.vertexShader=o.createShader(e,e.VERTEX_SHADER,"\n            attribute vec4 a_position;\n            attribute vec3 a_normal;\n            \n            uniform vec3 u_lightWorldPosition;\n            \n            uniform mat4 u_world;\n            uniform mat4 u_worldViewProjection;\n            uniform mat4 u_worldInverseTranspose;\n            \n            varying vec3 v_normal;\n            \n            varying vec3 v_surfaceToLight;\n            \n            void main() {\n                // Multiply the position by the matrix.\n                gl_Position = u_worldViewProjection * a_position;\n                \n                // orient the normals and pass to the fragment shader\n                v_normal = mat3(u_worldInverseTranspose) * a_normal;\n                \n                // compute the world position of the surfoace\n                vec3 surfaceWorldPosition = (u_world * a_position).xyz;\n                \n                // compute the vector of the surface to the light\n                // and pass it to the fragment shader\n                v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;\n            }\n        "),this.fragmentShader=o.createShader(e,e.FRAGMENT_SHADER,"\n            precision mediump float;\n\n            // Passed in from the vertex shader.\n            varying vec3 v_normal;\n            varying vec3 v_surfaceToLight;\n            \n            uniform vec4 u_color;\n            \n            void main() {\n                // because v_normal is a varying it's interpolated\n                // we it will not be a uint vector. Normalizing it\n                // will make it a unit vector again\n                vec3 normal = normalize(v_normal);\n                \n                vec3 surfaceToLightDirection = normalize(v_surfaceToLight);\n                \n                float light = dot(normal, surfaceToLightDirection);\n                \n                gl_FragColor = u_color;\n                \n                // Lets multiply just the color portion (not the alpha)\n                // by the light\n                gl_FragColor.rgb *= light;\n            }\n        ");let r=o.createProgram(e,this.vertexShader,this.fragmentShader);this.program=r,this.positionLocation=e.getAttribLocation(r,"a_position"),this.normalLocation=e.getAttribLocation(r,"a_normal"),this.colorLocation=e.getUniformLocation(r,"u_color"),this.worldViewProjectionLocation=e.getUniformLocation(r,"u_worldViewProjection"),this.worldInverseTransposeLocation=e.getUniformLocation(r,"u_worldInverseTranspose"),this.lightWorldPositionLocation=e.getUniformLocation(r,"u_lightWorldPosition"),this.worldLocation=e.getUniformLocation(r,"u_world");let i=o.cylinder({});this.treeInfo=i,this.positionBuffer=e.createBuffer(),this.normalBuffer=e.createBuffer()}draw({camera:t,trees:e,width:r,height:i,cable:n}){let a,s,l,c,h,{canvas:u,gl:f,positionLocation:d,program:m,colorLocation:p,normalLocation:y,worldViewProjectionLocation:g,worldInverseTransposeLocation:v,lightWorldPositionLocation:A,worldLocation:w,positionBuffer:b,normalBuffer:_,treeInfo:R}=this;u.width=r,u.height=i,f.viewport(0,0,r,i),f.clear(f.COLOR_BUFFER_BIT|f.DEPTH_BUFFER_BIT),f.enable(f.CULL_FACE),f.enable(f.DEPTH_TEST),f.useProgram(m),f.enableVertexAttribArray(d),f.bindBuffer(f.ARRAY_BUFFER,b),a=3,s=f.FLOAT,l=!1,c=0,h=0,f.vertexAttribPointer(d,a,s,l,c,h),f.enableVertexAttribArray(y),f.bindBuffer(f.ARRAY_BUFFER,_),a=3,s=f.FLOAT,l=!1,c=0,h=0,f.vertexAttribPointer(y,a,s,l,c,h);let x=r/i,F=o.perspective(60*Math.PI/180,x,1,2e3),T=o.translation(t.x,t.y,400),E=o.inverse(T),M=o.multiply(F,E);f.uniform4fv(p,[81/256,107/256,130/256,1]);const S=[t.x,t.y,-230];f.uniform3fv(A,S);let L=o.translation(t.x,t.y,0),B=o.multiply(M,L),P=o.inverse(L),C=o.transpose(P);f.uniformMatrix4fv(g,!1,B),f.uniformMatrix4fv(v,!1,C),f.uniformMatrix4fv(w,!1,L),f.bindBuffer(f.ARRAY_BUFFER,b),f.bufferData(f.ARRAY_BUFFER,new Float32Array([-r,-i,-250,+r,-i,-250,+r,+i,-250,-r,-i,-250,+r,+i,-250,-r,+i,-250]),f.STATIC_DRAW),f.bindBuffer(f.ARRAY_BUFFER,_),f.bufferData(f.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1]),f.STATIC_DRAW),f.drawArrays(f.TRIANGLES,0,6),L=o.translation(0,0,0),B=o.multiply(M,L),P=o.inverse(L),C=o.transpose(P),f.uniformMatrix4fv(g,!1,B),f.uniformMatrix4fv(v,!1,C),f.uniformMatrix4fv(w,!1,L);let I=[],U=[];for(let t=1,e=n.length;t<e;t++){let e=n[t],r=n[t-1],i=o.cableSegment({fromX:r.x,fromY:r.y,toX:e.x,toY:e.y});U=(I=I.concat(i.points)).concat(i.normals)}f.bindBuffer(f.ARRAY_BUFFER,b),f.bufferData(f.ARRAY_BUFFER,new Float32Array(I),f.STATIC_DRAW),f.bindBuffer(f.ARRAY_BUFFER,_),f.bufferData(f.ARRAY_BUFFER,new Float32Array(U),f.STATIC_DRAW),f.drawArrays(f.TRIANGLES,0,I.length/3),f.bindBuffer(f.ARRAY_BUFFER,b),f.bufferData(f.ARRAY_BUFFER,new Float32Array(R.points),f.STATIC_DRAW),f.bindBuffer(f.ARRAY_BUFFER,_),f.bufferData(f.ARRAY_BUFFER,new Float32Array(R.normals),f.STATIC_DRAW),e.forEach((t=>{let e=o.translation(t.x,t.y,0),r=o.multiply(M,e),i=o.inverse(e),n=o.transpose(i);f.uniformMatrix4fv(g,!1,r),f.uniformMatrix4fv(v,!1,n),f.uniformMatrix4fv(w,!1,e),f.drawArrays(f.TRIANGLES,0,R.points.length/3)}))}}},function(t,e,r){"use strict";let o={createShader(t,e,r){let o=t.createShader(e);return t.shaderSource(o,r),t.compileShader(o),o},createProgram(t,e,r){let o=t.createProgram();return t.attachShader(o,e),t.attachShader(o,r),t.linkProgram(o),o},perspective(t,e,r,o){let i=Math.tan(.5*Math.PI-.5*t),n=1/(r-o);return[i/e,0,0,0,0,i,0,0,0,0,(r+o)*n,-1,0,0,r*o*n*2,0]},subtractVectors:(t,e,r)=>((r=r||new Float32Array(3))[0]=t[0]-e[0],r[1]=t[1]-e[1],r[2]=t[2]-e[2],r),xRotation(t,e){e=e||new Float32Array(16);let r=Math.cos(t),o=Math.sin(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=o,e[7]=0,e[8]=0,e[9]=-o,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},yRotation(t,e){e=e||new Float32Array(16);let r=Math.cos(t),o=Math.sin(t);return e[0]=r,e[1]=0,e[2]=-o,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=o,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},transpose:(t,e)=>((e=e||new Float32Array(16))[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15],e),lookAt(t,e,r,i){i=i||new Float32Array(16);let n=o.normalize(o.subtractVectors(t,e)),a=o.normalize(o.cross(r,n)),s=o.normalize(o.cross(n,a));return i[0]=a[0],i[1]=a[1],i[2]=a[2],i[3]=0,i[4]=s[0],i[5]=s[1],i[6]=s[2],i[7]=0,i[8]=n[0],i[9]=n[1],i[10]=n[2],i[11]=0,i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i},cross:(t,e,r)=>((r=r||new Float32Array(3))[0]=t[1]*e[2]-t[2]*e[1],r[1]=t[2]*e[0]-t[0]*e[2],r[2]=t[0]*e[1]-t[1]*e[0],r),normalize(t,e){e=e||new Float32Array(3);let r=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return r>1e-5&&(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r),e},multiply(t,e){let r=t[0],o=t[1],i=t[2],n=t[3],a=t[4],s=t[5],l=t[6],c=t[7],h=t[8],u=t[9],f=t[10],d=t[11],m=t[12],p=t[13],y=t[14],g=t[15],v=e[0],A=e[1],w=e[2],b=e[3],_=e[4],R=e[5],x=e[6],F=e[7],T=e[8],E=e[9],M=e[10],S=e[11],L=e[12],B=e[13],P=e[14],C=e[15];return[v*r+A*a+w*h+b*m,v*o+A*s+w*u+b*p,v*i+A*l+w*f+b*y,v*n+A*c+w*d+b*g,_*r+R*a+x*h+F*m,_*o+R*s+x*u+F*p,_*i+R*l+x*f+F*y,_*n+R*c+x*d+F*g,T*r+E*a+M*h+S*m,T*o+E*s+M*u+S*p,T*i+E*l+M*f+S*y,T*n+E*c+M*d+S*g,L*r+B*a+P*h+C*m,L*o+B*s+P*u+C*p,L*i+B*l+P*f+C*y,L*n+B*c+P*d+C*g]},translation:(t,e,r)=>[1,0,0,0,0,1,0,0,0,0,1,0,t,e,r,1],translate:(t,e,r,i)=>o.multiply(t,o.translation(e,r,i)),inverse(t){let e=t[0],r=t[1],o=t[2],i=t[3],n=t[4],a=t[5],s=t[6],l=t[7],c=t[8],h=t[9],u=t[10],f=t[11],d=t[12],m=t[13],p=t[14],y=t[15],g=u*y,v=p*f,A=s*y,w=p*l,b=s*f,_=u*l,R=o*y,x=p*i,F=o*f,T=u*i,E=o*l,M=s*i,S=c*m,L=d*h,B=n*m,P=d*a,C=n*h,I=c*a,U=e*m,D=d*r,Y=e*h,W=c*r,k=e*a,O=n*r,j=g*a+w*h+b*m-(v*a+A*h+_*m),H=v*r+R*h+T*m-(g*r+x*h+F*m),z=A*r+x*a+E*m-(w*r+R*a+M*m),V=_*r+F*a+M*h-(b*r+T*a+E*h),G=1/(e*j+n*H+c*z+d*V);return[G*j,G*H,G*z,G*V,G*(v*n+A*c+_*d-(g*n+w*c+b*d)),G*(g*e+x*c+F*d-(v*e+R*c+T*d)),G*(w*e+R*n+M*d-(A*e+x*n+E*d)),G*(b*e+T*n+E*c-(_*e+F*n+M*c)),G*(S*l+P*f+C*y-(L*l+B*f+I*y)),G*(L*i+U*f+W*y-(S*i+D*f+Y*y)),G*(B*i+D*l+k*y-(P*i+U*l+O*y)),G*(I*i+Y*l+O*f-(C*i+W*l+k*f)),G*(B*u+I*p+L*s-(C*p+S*s+P*u)),G*(Y*p+S*o+D*u-(U*u+W*p+L*o)),G*(U*s+O*p+P*o-(k*p+B*o+D*s)),G*(k*u+C*o+W*s-(Y*s+O*u+I*o))]},cylinder({length:t=500,radius:e=10}){let r=[],o=[],i=2*Math.PI/12,n=t/2,a=0,s=i;for(let t=0;t<12;t++){let t=Math.cos(a),l=Math.sin(a),c=e*t,h=e*l,u=Math.cos(s),f=Math.sin(s),d=e*u,m=e*f;r.push(c,h,n,d,m,n,0,0,n),o.push(0,1,0,0,1,0,0,1,0),r.push(c,h,-n,d,m,-n,c,h,n,d,m,n,c,h,n,d,m,-n),o.push(t,l,0,u,f,0,t,l,0,u,f,0,t,l,0,u,f,0),a=s,s+=i}return{points:r,normals:o}},cableSegment({fromX:t,fromY:e,toX:r,toY:o}){let i=[],n=[],a=-240,s=2*Math.PI/12,l=r-t,c=o-e,h=Math.sqrt(l*l+c*c),u=Math.ceil(h/5),f=l/u,d=c/u,m=t,p=e;for(let t=0;t<u;t++){let t=0,e=s;for(let r=0;r<12;r++){let r=5*Math.cos(t),o=5*Math.sin(t),l=5*Math.cos(e),c=5*Math.sin(e);i.push(m+r,p+o,a,m+l,p+c,a,m,p,a),n.push(1,1,0,1,1,0,1,1,0),t=e,e+=s}m+=f,p+=d}return{points:i,normals:n}}};t.exports=o},function(t,e,r){r(0),r(1),r(2),t.exports=r(4)},function(t,e,r){"use strict";const o=r(0);setTimeout((()=>{window.app=new o}))}])</script>