<!doctype html><meta name=viewport content="width=device-width"><title>CLAWZ - js13kGames 2025</title><link rel=icon href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">üêæ</text></svg>'><style>html{background-color:#000}body,html{margin:0;padding:0;overflow:hidden}</style><div id=container></div><script type=module>import{Vector3 as m,Line3 as Ae,Plane as B,Triangle as Oe,Mesh as R,Ray as Ie,MathUtils as Xe,Matrix4 as Ue,SphereGeometry as We,BoxGeometry as de,MeshStandardMaterial as Ge,InstancedMesh as qe,DynamicDrawUsage as Ye,Object3D as Ze,Raycaster as Je,Vector2 as ue,Clock as Ke,WebGLRenderer as $e,PCFSoftShadowMap as Qe,Scene as et,PerspectiveCamera as tt,AmbientLight as nt,DirectionalLight as st,HemisphereLight as it,MeshBasicMaterial as De,PlaneGeometry as ge,ShadowMaterial as ot,MeshPhysicalMaterial as Re,Sphere as rt,Box3 as at,PlaneHelper as lt,BufferGeometry as ct,Float32BufferAttribute as xe}from"/2025/webxr/three.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();class ht{static createButton(e,t={}){const n=document.createElement("button");function s(a){let d=null;async function p(f){f.addEventListener("end",c),await e.xr.setSession(f),n.textContent="STOP XR",d=f}function c(){d.removeEventListener("end",c),n.textContent="START XR",d=null}n.style.display="",n.style.cursor="pointer",n.style.left="calc(50% - 50px)",n.style.width="100px",n.textContent="START XR";const g={...t,optionalFeatures:["local-floor","bounded-floor","layers",...t.optionalFeatures||[]]};n.onmouseenter=function(){n.style.opacity="1.0"},n.onmouseleave=function(){n.style.opacity="0.5"},n.onclick=function(){d===null?navigator.xr.requestSession(a,g).then(p):(d.end(),navigator.xr.offerSession!==void 0&&navigator.xr.offerSession(a,g).then(p).catch(f=>{console.warn(f)}))},navigator.xr.offerSession!==void 0&&navigator.xr.offerSession(a,g).then(p).catch(f=>{console.warn(f)})}function i(){n.style.display="",n.style.cursor="auto",n.style.left="calc(50% - 75px)",n.style.width="150px",n.onmouseenter=null,n.onmouseleave=null,n.onclick=null}function o(){i(),n.textContent="XR NOT SUPPORTED"}function l(a){i(),console.warn("Exception when trying to call xr.isSessionSupported",a),n.textContent="XR NOT ALLOWED"}function h(a){a.style.position="absolute",a.style.bottom="20px",a.style.padding="12px 6px",a.style.border="1px solid #fff",a.style.borderRadius="4px",a.style.background="rgba(0,0,0,0.1)",a.style.color="#fff",a.style.font="normal 13px sans-serif",a.style.textAlign="center",a.style.opacity="0.5",a.style.outline="none",a.style.zIndex="999"}if("xr"in navigator)return n.id="XRButton",n.style.display="none",h(n),navigator.xr.isSessionSupported("immersive-ar").then(function(a){a?s("immersive-ar"):navigator.xr.isSessionSupported("immersive-vr").then(function(d){d?s("immersive-vr"):o()}).catch(l)}).catch(l),n;{const a=document.createElement("a");return window.isSecureContext===!1?(a.href=document.location.href.replace(/^http:/,"https:"),a.innerHTML="WEBXR NEEDS HTTPS"):(a.href="https://immersiveweb.dev/",a.innerHTML="WEBXR NOT AVAILABLE"),a.style.left="calc(50% - 90px)",a.style.width="180px",a.style.textDecoration="none",h(a),a}}}const $=0,dt=1,ut=new m,we=new Ae,oe=new B,ye=new m,K=new Oe;class pt{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new Me,this.unassigned=new Me,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.vertices.push(new ft(e[t]));this._compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(n){const s=n.geometry;if(s!==void 0){const i=s.attributes.position;if(i!==void 0)for(let o=0,l=i.count;o<l;o++){const h=new m;h.fromBufferAttribute(i,o).applyMatrix4(n.matrixWorld),t.push(h)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let n=0,s=t.length;n<s;n++)if(t[n].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const n=this.faces;let s=-1/0,i=1/0;for(let o=0,l=n.length;o<l;o++){const h=n[o],a=h.distanceToPoint(e.origin),d=h.normal.dot(e.direction);if(a>0&&d>=0)return null;const p=d!==0?-a/d:0;if(!(p<=0)&&(d>0?i=Math.min(p,i):s=Math.max(p,s),s>i))return null}return s!==-1/0?e.at(s,t):e.at(i,t),t}intersectsRay(e){return this.intersectRay(e,ut)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}_addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}_removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}_removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let n=e.outside;for(;n.next!==null&&n.next.face===e;)n=n.next;return this.assigned.removeSubList(t,n),t.prev=n.next=null,e.outside=null,t}}_deleteFaceVertices(e,t){const n=this._removeAllVerticesFromFace(e);if(n!==void 0)if(t===void 0)this.unassigned.appendChain(n);else{let s=n;do{const i=s.next;t.distanceToPoint(s.point)>this.tolerance?this._addVertexToFace(s,t):this.unassigned.append(s),s=i}while(s!==null)}return this}_resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const n=t.next;let s=this.tolerance,i=null;for(let o=0;o<e.length;o++){const l=e[o];if(l.mark===$){const h=l.distanceToPoint(t.point);if(h>s&&(s=h,i=l),s>1e3*this.tolerance)break}}i!==null&&this._addVertexToFace(t,i),t=n}while(t!==null)}return this}_computeExtremes(){const e=new m,t=new m,n=[],s=[];for(let i=0;i<3;i++)n[i]=s[i]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let i=0,o=this.vertices.length;i<o;i++){const l=this.vertices[i],h=l.point;for(let a=0;a<3;a++)h.getComponent(a)<e.getComponent(a)&&(e.setComponent(a,h.getComponent(a)),n[a]=l);for(let a=0;a<3;a++)h.getComponent(a)>t.getComponent(a)&&(t.setComponent(a,h.getComponent(a)),s[a]=l)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:n,max:s}}_computeInitialHull(){const e=this.vertices,t=this._computeExtremes(),n=t.min,s=t.max;let i=0,o=0;for(let c=0;c<3;c++){const g=s[c].point.getComponent(c)-n[c].point.getComponent(c);g>i&&(i=g,o=c)}const l=n[o],h=s[o];let a,d;i=0,we.set(l.point,h.point);for(let c=0,g=this.vertices.length;c<g;c++){const f=e[c];if(f!==l&&f!==h){we.closestPointToPoint(f.point,!0,ye);const x=ye.distanceToSquared(f.point);x>i&&(i=x,a=f)}}i=-1,oe.setFromCoplanarPoints(l.point,h.point,a.point);for(let c=0,g=this.vertices.length;c<g;c++){const f=e[c];if(f!==l&&f!==h&&f!==a){const x=Math.abs(oe.distanceToPoint(f.point));x>i&&(i=x,d=f)}}const p=[];if(oe.distanceToPoint(d.point)<0){p.push(E.create(l,h,a),E.create(d,h,l),E.create(d,a,h),E.create(d,l,a));for(let c=0;c<3;c++){const g=(c+1)%3;p[c+1].getEdge(2).setTwin(p[0].getEdge(g)),p[c+1].getEdge(1).setTwin(p[g+1].getEdge(0))}}else{p.push(E.create(l,a,h),E.create(d,l,h),E.create(d,h,a),E.create(d,a,l));for(let c=0;c<3;c++){const g=(c+1)%3;p[c+1].getEdge(2).setTwin(p[0].getEdge((3-c)%3)),p[c+1].getEdge(0).setTwin(p[g+1].getEdge(1))}}for(let c=0;c<4;c++)this.faces.push(p[c]);for(let c=0,g=e.length;c<g;c++){const f=e[c];if(f!==l&&f!==h&&f!==a&&f!==d){i=this.tolerance;let x=null;for(let y=0;y<4;y++){const T=this.faces[y].distanceToPoint(f.point);T>i&&(i=T,x=this.faces[y])}x!==null&&this._addVertexToFace(f,x)}}return this}_reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const n=this.faces[t];n.mark===$&&e.push(n)}return this.faces=e,this}_nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const n=this.assigned.first().face;let s=n.outside;do{const i=n.distanceToPoint(s.point);i>t&&(t=i,e=s),s=s.next}while(s!==null&&s.face===n);return e}}_computeHorizon(e,t,n,s){this._deleteFaceVertices(n),n.mark=dt;let i;t===null?i=t=n.getEdge(0):i=t.next;do{const o=i.twin,l=o.face;l.mark===$&&(l.distanceToPoint(e)>this.tolerance?this._computeHorizon(e,o,l,s):s.push(i)),i=i.next}while(i!==t);return this}_addAdjoiningFace(e,t){const n=E.create(e,t.tail(),t.head());return this.faces.push(n),n.getEdge(-1).setTwin(t.twin),n.getEdge(0)}_addNewFaces(e,t){this.newFaces=[];let n=null,s=null;for(let i=0;i<t.length;i++){const o=t[i],l=this._addAdjoiningFace(e,o);n===null?n=l:l.next.setTwin(s),this.newFaces.push(l.face),s=l}return n.next.setTwin(s),this}_addVertexToHull(e){const t=[];return this.unassigned.clear(),this._removeVertexFromFace(e,e.face),this._computeHorizon(e.point,null,e.face,t),this._addNewFaces(e,t),this._resolveUnassignedPoints(this.newFaces),this}_cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}_compute(){let e;for(this._computeInitialHull();(e=this._nextVertexToAdd())!==void 0;)this._addVertexToHull(e);return this._reindexFaces(),this._cleanup(),this}}class E{constructor(){this.normal=new m,this.midpoint=new m,this.area=0,this.constant=0,this.outside=null,this.mark=$,this.edge=null}static create(e,t,n){const s=new E,i=new re(e,s),o=new re(t,s),l=new re(n,s);return i.next=l.prev=o,o.next=i.prev=l,l.next=o.prev=i,s.edge=i,s.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),n=this.edge.next.head();return K.set(e.point,t.point,n.point),K.getNormal(this.normal),K.getMidpoint(this.midpoint),this.area=K.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class re{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class ft{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class Me{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}class ve extends ct{constructor(e=[]){super();const t=[],n=[],i=new pt().setFromPoints(e).faces;for(let o=0;o<i.length;o++){const l=i[o];let h=l.edge;do{const a=h.head().point;t.push(a.x,a.y,a.z),n.push(l.normal.x,l.normal.y,l.normal.z),h=h.next}while(h!==l.edge)}this.setAttribute("position",new xe(t,3)),this.setAttribute("normal",new xe(n,3))}}const mt=new m;class G{constructor(e=1.4,t=1e-4){this.minSizeForBreak=e,this.smallDelta=t,this.tempLine1=new Ae,this.tempPlane1=new B,this.tempPlane2=new B,this.tempPlane_Cut=new B,this.tempCM1=new m,this.tempCM2=new m,this.tempVector3=new m,this.tempVector3_2=new m,this.tempVector3_3=new m,this.tempVector3_P0=new m,this.tempVector3_P1=new m,this.tempVector3_P2=new m,this.tempVector3_N0=new m,this.tempVector3_N1=new m,this.tempVector3_AB=new m,this.tempVector3_CB=new m,this.tempResultObjects={object1:null,object2:null},this.segments=[];const n=30*30;for(let s=0;s<n;s++)this.segments[s]=!1}prepareBreakableObject(e,t,n,s,i){const o=e.userData;o.mass=t,o.velocity=n.clone(),o.angularVelocity=s.clone(),o.breakable=i}subdivideByImpact(e,t,n,s,i){const o=[],l=this.tempPlane1,h=this.tempPlane2;this.tempVector3.addVectors(t,n),l.setFromCoplanarPoints(t,e.position,this.tempVector3);const a=i+s,d=this;function p(c,g,f,x){if(Math.random()<x*.05||x>a){o.push(c);return}let y=Math.PI;x===0?(h.normal.copy(l.normal),h.constant=l.constant):x<=s?(y=(f-g)*(.2+.6*Math.random())+g,d.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(n,y).add(t),h.setFromCoplanarPoints(t,d.tempVector3,d.tempVector3_2)):(y=(.5*(x&1)+.2*(2-Math.random()))*Math.PI,d.tempVector3_2.copy(t).sub(c.position).applyAxisAngle(n,y).add(c.position),d.tempVector3_3.copy(n).add(c.position),h.setFromCoplanarPoints(c.position,d.tempVector3_3,d.tempVector3_2)),d.cutByPlane(c,h,d.tempResultObjects);const T=d.tempResultObjects.object1,z=d.tempResultObjects.object2;T&&p(T,g,y,x+1),z&&p(z,y,f,x+1)}return p(e,0,2*Math.PI,0),o}cutByPlane(e,t,n){const s=e.geometry,i=s.attributes.position.array,o=s.attributes.normal.array,l=i.length/3;let h=l/3,a=s.getIndex();a&&(a=a.array,h=a.length/3);function d(u,w){const v=u*3+w;return a?a[v]:v}const p=[],c=[],g=this.smallDelta,f=l*l;for(let u=0;u<f;u++)this.segments[u]=!1;const x=this.tempVector3_P0,y=this.tempVector3_P1,T=this.tempVector3_N0,z=this.tempVector3_N1;for(let u=0;u<h-1;u++){const w=d(u,0),v=d(u,1),L=d(u,2);T.set(o[w],o[w]+1,o[w]+2);for(let S=u+1;S<h;S++){const b=d(S,0),_=d(S,1),J=d(S,2);z.set(o[b],o[b]+1,o[b]+2),1-T.dot(z)<g&&(w===b||w===_||w===J?v===b||v===_||v===J?(this.segments[w*l+v]=!0,this.segments[v*l+w]=!0):(this.segments[L*l+w]=!0,this.segments[w*l+L]=!0):(v===b||v===_||v===J)&&(this.segments[L*l+v]=!0,this.segments[v*l+L]=!0))}}const Z=this.tempPlane_Cut;e.updateMatrix(),G.transformPlaneToLocalSpace(t,e.matrix,Z);for(let u=0;u<h;u++){const w=d(u,0),v=d(u,1),L=d(u,2);for(let S=0;S<3;S++){const b=S===0?w:S===1?v:L,_=S===0?v:S===1?L:w;if(this.segments[b*l+_])continue;this.segments[b*l+_]=!0,this.segments[_*l+b]=!0,x.set(i[3*b],i[3*b+1],i[3*b+2]),y.set(i[3*_],i[3*_+1],i[3*_+2]);let D=0,O=Z.distanceToPoint(x);O>g?(D=2,c.push(x.clone())):O<-g?(D=1,p.push(x.clone())):(D=3,p.push(x.clone()),c.push(x.clone()));let I=0;if(O=Z.distanceToPoint(y),O>g?(I=2,c.push(y.clone())):O<-g?(I=1,p.push(y.clone())):(I=3,p.push(y.clone()),c.push(y.clone())),D===1&&I===2||D===2&&I===1){this.tempLine1.start.copy(x),this.tempLine1.end.copy(y);let X=new m;if(X=Z.intersectLine(this.tempLine1,X),X===null)return console.error("Internal error: segment does not intersect plane."),n.segmentedObject1=null,n.segmentedObject2=null,0;p.push(X),c.push(X.clone())}}}const me=e.userData.mass*.5;this.tempCM1.set(0,0,0);let ne=0;const H=p.length;if(H>0){for(let u=0;u<H;u++)this.tempCM1.add(p[u]);this.tempCM1.divideScalar(H);for(let u=0;u<H;u++){const w=p[u];w.sub(this.tempCM1),ne=Math.max(ne,w.x,w.y,w.z)}this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);let se=0;const j=c.length;if(j>0){for(let u=0;u<j;u++)this.tempCM2.add(c[u]);this.tempCM2.divideScalar(j);for(let u=0;u<j;u++){const w=c[u];w.sub(this.tempCM2),se=Math.max(se,w.x,w.y,w.z)}this.tempCM2.add(e.position)}let k=null,N=null,ie=0;return H>4&&(k=new R(new ve(p),e.material),k.position.copy(this.tempCM1),k.quaternion.copy(e.quaternion),this.prepareBreakableObject(k,me,e.userData.velocity,e.userData.angularVelocity,2*ne>this.minSizeForBreak),ie++),j>4&&(N=new R(new ve(c),e.material),N.position.copy(this.tempCM2),N.quaternion.copy(e.quaternion),this.prepareBreakableObject(N,me,e.userData.velocity,e.userData.angularVelocity,2*se>this.minSizeForBreak),ie++),n.object1=k,n.object2=N,ie}static transformFreeVector(e,t){const n=e.x,s=e.y,i=e.z,o=t.elements;return e.x=o[0]*n+o[4]*s+o[8]*i,e.y=o[1]*n+o[5]*s+o[9]*i,e.z=o[2]*n+o[6]*s+o[10]*i,e}static transformFreeVectorInverse(e,t){const n=e.x,s=e.y,i=e.z,o=t.elements;return e.x=o[0]*n+o[1]*s+o[2]*i,e.y=o[4]*n+o[5]*s+o[6]*i,e.z=o[8]*n+o[9]*s+o[10]*i,e}static transformTiedVectorInverse(e,t){const n=e.x,s=e.y,i=e.z,o=t.elements;return e.x=o[0]*n+o[1]*s+o[2]*i-o[12],e.y=o[4]*n+o[5]*s+o[6]*i-o[13],e.z=o[8]*n+o[9]*s+o[10]*i-o[14],e}static transformPlaneToLocalSpace(e,t,n){n.normal.copy(e.normal),n.constant=e.constant;const s=G.transformTiedVectorInverse(e.coplanarPoint(mt),t);G.transformFreeVectorInverse(n.normal,t),n.constant=-s.dot(n.normal)}}new Ie;new B;Math.cos(70*Xe.DEG2RAD);new m;const Pe=new Ue,be=new m;class Ce{constructor(e,t,n,s,i){this.controller=t,this.handModel=e,this.envMap=null;let o;!i||!i.primitive||i.primitive==="sphere"?o=new We(1,10,10):i.primitive==="box"&&(o=new de(1,1,1));const l=new Ge;this.handMesh=new qe(o,l,30),this.handMesh.frustumCulled=!1,this.handMesh.instanceMatrix.setUsage(Ye),this.handMesh.castShadow=!0,this.handMesh.receiveShadow=!0,this.handModel.add(this.handMesh),this.joints=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"]}updateMesh(){const t=this.controller.joints;let n=0;for(let s=0;s<this.joints.length;s++){const i=t[this.joints[s]];i.visible&&(be.setScalar(i.jointRadius||.008),Pe.compose(i.position,i.quaternion,be),this.handMesh.setMatrixAt(s,Pe),n++)}this.handMesh.count=n,this.handMesh.instanceMatrix.needsUpdate=!0}}class gt extends Ze{constructor(e){super(),this.controller=e,this.motionController=null,this.envMap=null,this.mesh=null}updateMatrixWorld(e){super.updateMatrixWorld(e),this.motionController&&this.motionController.updateMesh()}}class xt{constructor(e=null,t=null){this.gltfLoader=e,this.path=null,this.onLoad=t}setPath(e){return this.path=e,this}createHandModel(e,t){const n=new gt(e);return e.addEventListener("connected",s=>{const i=s.data;i.hand&&!n.motionController&&(n.xrInputSource=i,t===void 0||t==="spheres"?n.motionController=new Ce(n,e,this.path,i.handedness,{primitive:"sphere"}):t==="boxes"?n.motionController=new Ce(n,e,this.path,i.handedness,{primitive:"box"}):t==="mesh"&&(n.motionController=new XRHandMeshModel(n,e,this.path,i.handedness,this.gltfLoader,this.onLoad)))}),e.addEventListener("disconnected",()=>{n.clear(),n.motionController=null}),n}}const ae=new G;let Q=[];const wt=-9.81,q=0,Se=[16761221,11813180,15526869,14370117,13810252,9847589],Ee=[];let ee,te=[],U,W;const ce=[],_e=new xt,Ve=new Je,le=new ue,Te=new ue,Fe=new ue;let ze=new m,he=new m,A,M,C;const He=20,F=.25,Le=.5*F,Y=3/2,V=[];let P;var pe={BLUE:1875651,MAGENTA:11422877};const Be=new Ke,yt=()=>{const r=Be.getDelta();Be.getElapsedTime(),vt(r),zt(),Tt(r),C.render(M,A)},je=1,Mt=250,vt=r=>{V.forEach(e=>{e.userData.active&&(e.position.z+=je*r,P?e.position.z>P.position.z&&(P=e):P=e,e.position.z>Y&&ke(e))})},Pt=()=>{M=new et,M.backgroundColor=0;const r=window.innerWidth/window.innerHeight;A=new tt(75,r,.1,Y),A.position.set(0,1.6,Y);const e=new nt(16777215,1);M.add(e);const t=new st(16777215,1);t.position.set(0,10,0),t.castShadow=!0,t.shadow.mapSize.width=1024,t.shadow.mapSize.height=1024,M.add(t);const n=new it(16777215,pe.MAGENTA,3);n.position.set(.5,1,.25),M.add(n);const s=new R(new de(F/2,F/2,F/2),new De({color:16777215}));M.add(s)},bt=()=>{C=new $e({antialias:!0,alpha:!0}),C.setPixelRatio(window.devicePixelRatio),C.setSize(window.innerWidth,window.innerHeight),C.shadowMap.enabled=!0,C.shadowMap.type=Qe,C.setAnimationLoop(yt),C.xr.enabled=!0,document.body.appendChild(C.domElement);const r={requiredFeatures:["hand-tracking"]},e=ht.createButton(C,r);e.style.backgroundColor="skyblue",document.body.appendChild(e)},Ct=()=>{const r=Y*2,e=new R(new ge(r,r,10*r,10*r),new De({color:pe.MAGENTA,wireframe:!0}));e.rotation.x=Math.PI/-2,e.position.y=q-.001,M.add(e);const t=new ot({opacity:.4}),n=new ge(3,3),s=new R(n,t);s.rotation.x=-Math.PI/2,s.position.y=q,s.receiveShadow=!0,M.add(s)},St=()=>{const r=new de(F,F,F);for(let e=0;e<He;e++){V.push(new R(r,new Re({color:pe.BLUE})));const t=V[e];ke(t),t.userData.type="cube",t.castShadow=!0,t.receiveShadow=!0,M.add(t)}Et()},ke=r=>{r.visible=!1,r.userData.active=!1,r.position.z=-Y,r.position.x=(Math.random()-.5)*2,r.position.y=Math.random()*.75+1},Et=()=>{setInterval(()=>{for(let r=0;r<He;r++)if(V[r].userData.active===!1){V[r].userData.active=!0,V[r].visible=!0;break}},Mt)},_t=()=>{const r=new m(Math.random()-.5,Math.random()-.5,Math.random()-.5).normalize(),e=F/4,t=[-1.5*e,-.5*e,.5*e,1.5*e];ee=new m(0,1.6,0),te=t.map(n=>new B().setFromNormalAndCoplanarPoint(r,r.clone().multiplyScalar(n).add(ee))),Ne()},Ne=()=>{Ee.forEach(r=>{M.remove(r),r.geometry.dispose(),r.material.dispose()}),te.forEach(r=>{const e=new lt(r,1,16776960);Ee.push(e),M.add(e)})},Vt=()=>{_t(),P=null,V.forEach(r=>{P?r.position.distanceTo(ee)<P.position.distanceTo(ee)&&(P=r):P=r}),fe(P)},fe=r=>{for(const s of Q)M.remove(s.mesh),s.mesh.geometry.dispose(),s.mesh.material.dispose();Q=[];const e=new m(0,0,0),t=new m(0,0,0);ae.prepareBreakableObject(r,Le,e,t,!0);let n=[r];for(const s of te){let i=[];for(const o of n){let l={object1:null,object2:null};ae.cutByPlane(o,s,l)===2?(M.remove(o),o.geometry.dispose(),o.material.dispose(),l.object1&&i.push(l.object1),l.object2&&i.push(l.object2)):i.push(o)}n=i}n.forEach((s,i)=>{s.castShadow=!0,s.receiveShadow=!0;const o=Se[i%Se.length];s.material=new Re({color:o});const l=Le,h=new m((Math.random()-.5)*.2,Math.random()*.2,(Math.random()-.5)*.2),a=new m((Math.random()-.5)*2,(Math.random()-.5)*2,(Math.random()-.5)*2);ae.prepareBreakableObject(s,l,h,a,!0),M.add(s),Q.push({mesh:s,velocity:h,angularVelocity:a})})},Tt=r=>{for(const e of Q)e.velocity.y+=wt*r,e.mesh.position.addScaledVector(e.velocity,r),e.mesh.position.y>q&&(e.mesh.position.z+=je*r),e.mesh.rotation.x+=e.angularVelocity.x*r,e.mesh.rotation.y+=e.angularVelocity.y*r,e.mesh.rotation.z+=e.angularVelocity.z*r,e.mesh.position.y<q&&(e.mesh.position.y=q,e.velocity.y=0,e.angularVelocity.multiplyScalar(.7),e.velocity.x*=.7,e.velocity.z*=.7)},Ft=(r,e,t)=>{te=[new B().setFromCoplanarPoints(r,e,t)],Ne()};function Lt(){U=C.xr.getHand(0),U.add(_e.createHandModel(U,"boxes")),M.add(U),ce.push(U),W=C.xr.getHand(1),W.add(_e.createHandModel(W,"boxes")),M.add(W),ce.push(W)}const Bt=.01,At="index-finger-tip";function Dt(r,e){const t=r.joints[e];if(t)return t.position}function Rt(r,e){const t=Dt(r,At);if(t){const n=new rt(t,Bt),s=new at().setFromObject(e);return n.intersectsBox(s)}else return!1}function zt(){ce.forEach(r=>{V.forEach(e=>{r&&Rt(r,e)&&fe(e)})})}const Ht=()=>{window.addEventListener("resize",Ot,!1),window.addEventListener("keydown",r=>{r.code==="Space"&&Vt()}),document.addEventListener("pointerdown",jt),document.addEventListener("pointerup",kt),document.addEventListener("pointermove",Nt)};function jt(r){Fe.x=r.clientX,Fe.y=r.clientY}function kt(r){Te.x=r.clientX,Te.y=r.clientY,Ft(he,ze,A.position),fe(P),P=null}const Nt=r=>{le.x=r.clientX/window.innerWidth*2-1,le.y=-(r.clientY/window.innerHeight)*2+1,Ve.setFromCamera(le,A);const e=Ve.intersectObjects(V,!1);if(e.length>0){const t=e[0].object;t.userData.type==="cube"&&(he||(he=e[0].point),ze=e[0].point,P||(P=t))}};function Ot(){A.aspect=window.innerWidth/window.innerHeight,A.updateProjectionMatrix(),C.setSize(window.innerWidth,window.innerHeight)}bt();Pt();Ct();St();Lt();Ht();</script>