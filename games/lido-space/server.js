/**
 * This file is part of JS13kGames - SPACE.
 * Lido Space is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * Lido Space is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with Lido Space.  If not, see <https://www.gnu.org/licenses/>.
 */

"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t="NAMES";function e(t){const e=`${t}:`;return{debug:console.log.bind(console,e),log:console.log.bind(console,e),info:console.info.bind(console,e),warn:console.warn.bind(console,e),error:console.error.bind(console,e)}}function n(t){return t*Math.PI/180}function s(t,e){return{type:"ADD_NAME",payload:{hue:Math.floor(360*Math.random()),id:t,name:e}}}function o(t,e){return{type:"ADD_POINT",payload:{id:t,point:e}}}function i(t,e){return{type:"JOIN_GAME",payload:{id:t,host:e}}}function a(t,e){let n=[];switch(e){case"new":n=function(t){return[{id:t,x:160,y:100}]}(t);break;case"join":n=function(t){let e=0;if(t.startsWith("AI-")){const n=/\d+/.exec(t);n&&(e=parseInt(n[0],10)%4)}return[{id:t,...[{x:0,y:100},{x:320,y:100},{x:160,y:0},{x:160,y:200}][e]}]}(t)}return{type:"SELECT_MODE",payload:{id:t,mode:e,points:n}}}const r={colors:[],connections:[],games:[],modes:[],points:[],scenes:[],timers:[],users:[]};const c=e("store");const d=new class{constructor(e){this.reducer=e,this.state=e(void 0,{type:""}),storage.set(t,[]),c.debug("Storage initialised.")}async dispatch(t){this.state=this.reducer(this.state,t),c.debug(`Dispatched ${JSON.stringify(t)}.`);const e={new:ROLE_HOST,join:ROLE_OPPONENT};switch(t.type){case"ADD_NAME":await this._saveName(t.payload);break;case"FINISH_GAME":await this._saveHighscore({id:t.payload.id,score:this.calculateScore({socketId:t.payload.id,role:t.payload.role})});break;case"SELECT_MODE":await this._saveRole({id:t.payload.id,role:e[t.payload.mode]})}}calculateScore({socketId:t,role:e}){const n=this.state.points.filter((e=>e.id===t));switch(e){case ROLE_HOST:return n.length>0?n.reduce(((t,e,n,s)=>{return 0===n?0:Math.floor(t+function(t){return function(t,e){return t.x*e.x+t.y*e.y}(t,t)**.5}((o=e,i=s[n-1],{x:o.x-i.x,y:o.y-i.y})));var o,i}),0):0;case ROLE_OPPONENT:return Array.from(new Set(n.map((t=>`${t.x}#${t.y}`)))).length;default:return 0}}findGameAvailableForJoin(){const t=this.state.games.find((t=>!!t.opponents.find((t=>t.startsWith("AI-")))));return t||null}getGameForHost(t){const e=this._findGameBySocketId(t);if(!e)return null;const n=this.state.colors.find((t=>t.id===e.host));return{host:{color:n?n.value:"transparent",name:this._resolveNameForId(e.host)},opponents:e.opponents.map((t=>{const e=this.state.colors.find((e=>e.id===t));return{color:e?e.value:"transparent",name:this._resolveNameForId(t)}}))}}getGameForOpponent(t){const e=this._findGameBySocketId(t);if(!e)return null;const n=this.state.colors.find((e=>e.id===t));return{host:{color:n?n.value:"transparent",name:this._resolveNameForId(e.host)},opponents:e.opponents.map((t=>{const e=this.state.colors.find((e=>e.id===t));return{color:e?e.value:"transparent",name:this._resolveNameForId(t)}}))}}getPointsForHost(t){const e=this._findGameBySocketId(t);return e?this.state.points.filter((t=>t.id===e.host)).map((t=>[t.x,t.y])).slice(-13):[]}getOpponentIdsOfHost(t){const e=this._findGameBySocketId(t);return e?e.opponents:[]}getPointsForOpponents(t){const e=this._findGameBySocketId(t);if(!e)return[];return e.opponents.map((t=>this.state.points.filter((e=>e.id===t)).map((t=>[t.x,t.y]))))}getPointsForOpponent(t){if(!this._findGameBySocketId(t))return[];return this.state.points.filter((e=>e.id===t)).map((t=>[t.x,t.y]))}getState(){return this.state}getTurns(t){const e=this.state.timers.find((e=>e.id===t));return e?e.turns:0}_findGameBySocketId(t){return this.state.games.find((e=>!(e.host!==t)||!!e.opponents.includes(t)))||null}_resolveNameForId(t){const e=this.state.users.find((e=>e.id===t));return e?e.name:null}async _saveName({name:e}){if(e.startsWith("Bot"))return;const n=await storage.get(t);await storage.set(t,[].concat(n).concat({name:e,role:ROLE_UNKNOWN,score:0}))}async _saveHighscore({id:e,score:n}){const s=this.state.users.find((t=>t.id===e));if(s.name.startsWith("Bot"))return;const o=await storage.get(t);await storage.set(t,o.map((t=>(t.name===s.name&&(t.score=n),t))))}async _saveRole({id:e,role:n}){const s=this.state.users.find((t=>t.id===e));if(s.name.startsWith("Bot"))return;const o=await storage.get(t);await storage.set(t,o.map((t=>(t.name===s.name&&(t.role=n),t))))}}((function(t,e){if(void 0===t)return r;switch(e.type){case"ADD_NAME":return function(t,e){const n=`hsl(${e.hue}, 80%, 50%)`,s=[].concat(t.colors).concat({id:e.id,value:n}),o=[].concat(t.modes).concat({id:e.id,mode:null}),i=[].concat(t.users).concat({id:e.id,name:e.name});return Object.assign({},t,{colors:s,modes:o,users:i})}(t,e.payload);case"ADD_POINT":return function(t,e){const n={id:e.id,...e.point},s=[].concat(t.points).concat(n);return Object.assign({},t,{points:s})}(t,e.payload);case"CONNECT":return function(t,e){const n=[].concat(t.connections).concat(e.id),s=[].concat(t.scenes).concat({id:e.id,scene:"title"});return Object.assign({},t,{connections:n,scenes:s})}(t,e.payload);case"DISCONNECT":return function(t,e){const n=t.colors.filter((t=>t.id!==e.id)),s=t.connections.filter((t=>t!==e.id)),o=t.games.filter((t=>t.host!==e.id)).map((t=>({...t,opponents:t.opponents.filter((t=>t!==e.id))}))),i=t.modes.filter((t=>t.id!==e.id)),a=t.points.filter((t=>t.id!==e.id)),r=t.scenes.filter((t=>t.id!==e.id)),c=t.timers.filter((t=>t.id!==e.id)),d=t.users.filter((t=>t.id!==e.id));return Object.assign({},t,{colors:n,connections:s,games:o,modes:i,points:a,scenes:r,timers:c,users:d})}(t,e.payload);case"FINISH_GAME":return function(t,e){const n=t.modes.map((t=>t.id===e.id?{...t,mode:"fin"}:t)),s=t.scenes.map((t=>t.id===e.id?{...t,scene:"fin"}:t));return Object.assign({},t,{modes:n,scenes:s})}(t,e.payload);case"JOIN_GAME":return function(t,e){const n=t.games.map((t=>t.host===e.host?{...t,opponents:[].concat(t.opponents).concat(e.id)}:t));return Object.assign({},t,{games:n})}(t,e.payload);case"NAVIGATE":return function(t,e){const n=t.scenes.map((t=>t.id===e.id?{...e}:t));return Object.assign({},t,{scenes:n})}(t,e.payload);case"REMOVE_USER":return function(t,e){const{id:n}=e,s=t.users.filter((t=>t.id!==n));return Object.assign({},t,{users:s})}(t,e.payload);case"SELECT_MODE":return function(t,e){let n=t.games,s=t.points,o=t.timers;switch(e.mode){case"new":n=function(t,e){return[].concat(t.games).concat({host:e.id,opponents:[]})}(t,e),s=[].concat(t.points).concat(e.points),o=[].concat(t.timers).concat({id:e.id,turns:0});break;case"join":s=[].concat(t.points).concat(e.points)}const i=t.modes.map((t=>t.id===e.id?{id:e.id,mode:e.mode}:t));return Object.assign({},t,{games:n,modes:i,points:s,timers:o})}(t,e.payload);case"SWAP_USER":return function(t,e){const n=t.games.map((t=>({...t,opponents:t.opponents.map((t=>t===e.replacedId?e.id:t))}))),s=t.modes.map((t=>t.id===e.replacedId?{id:t.id,mode:null}:t)),o=t.points.map((t=>t.id===e.replacedId?{...t,id:e.id}:t));return Object.assign({},t,{games:n,modes:s,points:o})}(t,e.payload);case"UPDATE_NAME":return function(t,e){const{id:n,name:s}=e,o=t.users.map((t=>t.id===n?{...t,name:s}:t));return Object.assign({},t,{users:o})}(t,e.payload);case"UPDATE_TIMER":return function(t,e){const{id:n}=e,s=t.timers.map((t=>t.id===n?{...t,turns:t.turns+1}:t));return Object.assign({},t,{timers:s})}(t,e.payload);default:return t}})),p={x:160,y:100},l=e("io"),u={};let m=0;function f(t,e){let n=0,s=0;const o=d.getPointsForOpponent(t),[i,a]=o[o.length-1];switch(e){case 2:a+20<=200&&(s=20);break;case 3:i-32>=0&&(n=-32);break;case 1:i+32<=320&&(n=32);break;case 0:a-20>=0&&(s=-20)}return{x:i+n,y:a+s}}function h(t){const e=d.getOpponentIdsOfHost(t);u[t].emit("sync",{role:ROLE_HOST,points:d.getPointsForHost(t)}),e.forEach((e=>{u[t].emit("sync",{role:ROLE_OPPONENT,points:d.getPointsForOpponents(e)})})),e.map((t=>u[t])).filter(Boolean).forEach((n=>{n.emit("sync",{role:ROLE_HOST,points:d.getPointsForHost(t)}),e.forEach((t=>{n.emit("sync",{role:ROLE_OPPONENT,points:d.getPointsForOpponents(t)})}))}))}exports.highscore=async function(e,n){const s=await storage.get(t);n.send(s)},exports.io=async function(t){let e=null,r=ROLE_UNKNOWN;var c;await d.dispatch((c=t.id,{type:"CONNECT",payload:{id:c}})),u[t.id]=t,t.on("disconnect",(async()=>await async function(t){l.info(`Disconnected: ${t.id}`),await d.dispatch(function(t){return{type:"DISCONNECT",payload:{id:t}}}(t.id))}(t))),t.on("addUser",(async e=>{await d.dispatch(s(t.id,e.name))})),t.on("navigate",(async e=>{await d.dispatch(function(t,e){return{type:"NAVIGATE",payload:{id:t,scene:e}}}(t.id,e.scene))})),t.on("selectMode",(async e=>{let n;switch(await d.dispatch(a(t.id,e.mode)),e.mode){case"new":r=ROLE_HOST,await async function(t){for(let e=0;e<3;e++){const e=`AI-${m}`;await d.dispatch(s(e,`Bot No. ${m}`)),await d.dispatch(a(e,"join")),await d.dispatch(i(e,t)),m+=1}}(t.id),t.emit("joined",{...d.getGameForHost(t.id)}),t.emit("start",{role:r}),h(t.id);break;case"join":r=ROLE_OPPONENT,n=d.findGameAvailableForJoin(),n&&(await d.dispatch(function(t,e){return{type:"SWAP_USER",payload:{id:t,replacedId:e}}}(t.id,n.opponents.find((t=>t.startsWith("AI-"))))),t.emit("joined",{...d.getGameForOpponent(t.id)}),u[n.host].emit("joined",{...d.getGameForHost(n.host)}),t.emit("start",{role:r}),h(t.id))}})),t.on("keyUp",(async e=>{e.delta?(await d.dispatch(o(t.id,function(t){const e=130,{x:s,y:o}=function({radius:t,angle:e}){return{x:t*Math.cos(e),y:t*Math.sin(e)}}({radius:t*e%p.y,angle:n(Math.floor(Date.now()/100%360))});return{x:Math.floor(p.x+s),y:Math.floor(p.y+o)}}(e.delta))),await d.dispatch(o(t.id,{...p})),h(t.id)):e.direction&&(await d.dispatch(o(t.id,f(t.id,e.direction))),t.emit("sync",{role:r,points:d.getPointsForOpponents(t.id)}))})),e=setInterval((async()=>{if(!d.getGameForHost(t.id))return;d.getOpponentIdsOfHost(t.id).filter((t=>t.startsWith("AI-"))).forEach((async e=>{await async function(t){const e=(s=[2,3,1,0],s[Math.floor(Math.random()*s.length)]),n=f(t,e);var s;await d.dispatch(o(t,n))}(e),t.emit("sync",{role:ROLE_OPPONENT,points:d.getPointsForOpponents(e)})})),await d.dispatch(function(t){return{type:"UPDATE_TIMER",payload:{id:t}}}(t.id));var n;if(await(n=t.id,d.getTurns(n)>=13)){clearInterval(e),l.debug("GAME OVER",d.getState()),u[t.id].emit("gameOver");d.getOpponentIdsOfHost(t.id).forEach((t=>{u[t]&&u[t].emit("gameOver")})),d.dispatch(function(t,e){return{type:"FINISH_GAME",payload:{id:t,role:e}}}(t.id,r))}}),1e3),l.info(`Connected: ${t.id}`)};
