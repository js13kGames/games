!function(){"use strict";function t(t,i){let o=new SpeechSynthesisUtterance(t);o.lang="en-US",void 0!==i&&(o.voice=i),e.speak(o)}const e=window.speechSynthesis;AFRAME.registerSystem("game-state",{schema:{level:{type:"number",default:1}},init:function(){this.sceneEl=document.querySelector("a-scene"),this.camera=document.getElementById("camera"),this.levelEntity=document.getElementById("level"),this.lostStones=Array.from(document.querySelectorAll(".lostStone")),this.magicLight=document.querySelector("#magicLight"),this.wallContainer=document.querySelector("#wallContainer"),this.stoneContainer=document.getElementById("stoneContainer"),this.lastSlowTick=0,this.lastFinish=0,this.lostGame=!1,this.stoneCollectTime=void 0,this.energy=12e3,this.energyLowCondition=!1,this.dirLightStone=new THREE.Vector3,this.audioCtx=new(window.AudioContext||window.webkitAudioContext),this.speechSynth=window.speechSynthesis,this.oscillator=this.audioCtx.createOscillator(),this.biquadFilter=this.audioCtx.createBiquadFilter(),this.gainNode=this.audioCtx.createGain(),this.distortion=this.audioCtx.createWaveShaper(),this.oscillator.connect(this.gainNode),this.gainNode.connect(this.biquadFilter),this.biquadFilter.connect(this.distortion),this.distortion.connect(this.audioCtx.destination),this.oscillator.type="triangle",this.oscillator.frequency.value=0,this.oscillator.detune.value=100,this.biquadFilter.type="lowshelf",this.biquadFilter.frequency.value=300,this.biquadFilter.gain.value=25,this.distortion.curve=function(t){for(var e,i="number"==typeof t?t:50,o=new Float32Array(44100),n=Math.PI/180,r=0;r<44100;++r)e=2*r/44100-1,o[r]=(3+i)*e*20*n/(Math.PI+i*Math.abs(e));return o}(400),this.distortion.oversample="4x",this.oscillator.start(),this.magicLight.addEventListener("raycaster-intersection",t=>{if(this.magicLight.components["magic-light"].triggerPressed){let e=t.detail.els[0],i=this.magicLight.object3D.position.clone().sub(e.object3D.position).normalize();e.components["physics-body"].velocity.add(i.multiplyScalar(.001))}}),this.slowTick=AFRAME.utils.throttle(this.slowTick,250,this)},tick:function(t,e){this.lastFinish+=e,this.time=t,this.magicLight.components["magic-light"].triggerPressed&&(this.energy-=8);let i=1-Math.round(20*Math.random())/200;this.gainNode.gain.value=0,void 0!==this.stoneCollectTime&&t-this.stoneCollectTime<2500&&(this.oscillator.frequency.value=100*i+100*Math.sin(5e-4*(t-this.stoneCollectTime)),this.gainNode.gain.value=.05),this.slowTick(),this.magicLight.setAttribute("magic-light",{energy:this.energy})},slowTick:function(e,i){this.energy-=5;for(var o=this.lostStones.length-1;o>=0;o--){let e=this.lostStones[o];this.magicLight.object3D.position.distanceTo(e.object3D.position)<.1&&(this.lostStones.splice(o,1),e.parentNode.removeChild(e),this.energy=12e3,this.energyLowCondition=!1,this.stoneCollectTime=this.time,0!==this.lostStones.length&&t(`${this.lostStones.length} stones remaining.`))}if(!this.energyLowCondition&&this.energy<2400&&(t("Energy is low."),this.energyLowCondition=!0),this.energy<=0&&!1===this.lostGame)return this.lostGame=!0,void this.endGame();this.lastFinish>5e3&&0===this.lostStones.length&&(t("You have found the lost stone. Next Level!"),this.nextLevel())},nextLevel:function(t){this.energyLowCondition=!1,this.energy=12e3,this.lastFinish=0,this.stoneCollectTime=void 0,this.lostGame?this.levelEntity.components.level.reloadLevel():(this.data.level++,this.levelEntity.setAttribute("level",{difficulty:this.data.level})),this.lostGame=!1},endGame:function(){t("Enery depleted. You lost. Restart current level."),this.lostGame=!0,this.nextLevel()}}),AFRAME.registerComponent("level",{schema:{difficulty:{type:"number",default:1}},init:function(){this.sceneEl=document.querySelector("a-scene"),this.gameState=this.sceneEl.systems["game-state"],this.wallContainer=this.gameState.wallContainer,this.stoneContainer=this.gameState.stoneContainer},getNewWall:function(t,e,i,o){let n=document.createElement("a-entity");return n.classList.add("wall"),n.setAttribute("geometry",{width:t,height:e,depth:i,primitive:"box",buffer:!1,skipCache:!0}),n.setAttribute("physics-body",{mass:0,collidesOthers:!1}),n.setAttribute("position",{x:Math.random()*o-o/2,y:Math.random()*o-o/2,z:Math.random()*o-o/2}),n.setAttribute("rotation",{x:180*Math.random(),y:180*Math.random(),z:180*Math.random()}),n},getNewStone:function(t,e,i){let o=document.createElement("a-entity");return o.classList.add("lostStone"),o.setAttribute("mixin","sphere"),o.setAttribute("physics-body",{mass:0,collidesOthers:!0}),o.setAttribute("lost-stone-material",""),o},reloadLevel:function(){this.update()},update:function(){const e=this.data.difficulty;if(1===e&&t("Hello! You lost your precious energy stones in a shifted dimension. Use your magic light controller to make them visible and pull them closer to you. Collect them by touching. Each stone you collect will refill your energy bar. But be careful: your magic controller will drain energy when used."),e>1){this.wallContainer.innerHTML="";let t=3+e,i=[];for(let e=0;e<20;e++){let o=this.getNewWall(Math.random()+.5,Math.random()+.5,Math.random(),t+1);o.setAttribute("labyrinth-material",{color:`hsl(${Math.round(360*Math.random())}, ${Math.round(60*Math.random())}%, ${Math.round(50*Math.random())}%)`}),o.id="pwall-"+e,i.push(o),setTimeout(()=>{this.wallContainer.appendChild(o)},500*e)}for(let o=0;o<35*e;o++){let e=this.getNewWall(Math.random()+.5,Math.random()+.5,Math.random(),t+1),n=Math.floor(Math.random()*i.length);e.setAttribute("labyrinth-material",{color:`hsl(${Math.round(360*Math.random())}, ${Math.round(60*Math.random())}%, ${Math.round(50*Math.random())}%)`}),e.setAttribute("geometry","mergeTo","#pwall-"+n),setTimeout(()=>{this.wallContainer.appendChild(e)},500*o)}for(let i=0;i<2*e-1;i++){let e=this.getNewStone(.3+.4*Math.random(),.3+.4*Math.random(),.3+.4*Math.random());e.setAttribute("position",{x:Math.random()*t-t/2,y:Math.random()*t/2,z:Math.random()*t-t/2}),this.stoneContainer.appendChild(e),this.gameState.lostStones.push(e)}}},tick:function(){},remove:function(){}}),AFRAME.registerSystem("pseudo-physics",{schema:{gravity:{type:"vec3",default:new THREE.Vector3(0,-.001,0)},drag:{type:"number",default:.996}},init:function(){this.children=[],this.colliders=[],this.futurePos=new THREE.Vector3,this.futureChildBox=new THREE.Box3,this.futureColliderBox=new THREE.Box3,this.futureBSphere=new THREE.Sphere},tick:function(){for(let t of this.children){if(t.acceleration.multiplyScalar(0).add(this.data.gravity).multiplyScalar(t.data.mass),t.velocity.add(t.acceleration),this.futurePos.copy(t.el.object3D.position).add(t.velocity),t.data.collidesAgainst){this.futureChildBox.setFromCenterAndSize(this.futurePos,t.boundingBoxSize);for(let e of this.colliders)e.el!==t.el&&(this.futureChildBox.intersectsBox(e.boundingBox)&&(t.velocity.multiplyScalar(-.5),t.velocity.length()<.001&&t.velocity.set(0,0,0)),t.velocity.length()<1e-6&&t.velocity.set(0,0,0),this.futurePos.copy(t.el.object3D.position).add(t.velocity))}t.velocity.multiplyScalar(this.data.drag),(0!==t.data.gravity||t.data.collidesAgainst)&&t.el.setAttribute("position",this.futurePos)}},add:function(t){this.children.push(t),t.data.collidesOthers&&this.colliders.push(t)},remove:function(t){let e=this.children.indexOf(t);if(this.children.splice(e,1),t.data.collidesOthers){let e=this.colliders.indexOf(t);this.colliders.splice(e,1)}}}),AFRAME.registerComponent("physics-body",{schema:{mass:{type:"number",default:1},collidesOthers:{type:"bool",default:!1},collidesAgainst:{type:"bool",default:!1}},init:function(){this.velocity=new THREE.Vector3(0,0,0),this.acceleration=new THREE.Vector3(0,0,0),this.sceneEl=document.querySelector("a-scene"),this.system=this.sceneEl.systems["pseudo-physics"],this.boundingBox=(new THREE.Box3).setFromObject(this.el.object3D),this.boundingBoxSize=this.boundingBox.getSize(),this.system.add(this)},tick:function(){this.boundingBox.setFromObject(this.el.object3D),this.boundingBoxSize=this.boundingBox.getSize()},remove:function(){this.system.remove(this)}}),AFRAME.registerComponent("magic-light",{schema:{hand:{default:""},energy:{type:"number",default:1e4},maxEnergy:{type:"number",default:12e3}},createModel:function(){this.hullDimensions={width:.03,height:.04,depth:.15};let t=document.createElement("a-entity");t.setAttribute("geometry",Object.assign({primitive:"box"},this.hullDimensions)),t.setAttribute("material",{color:"rgba(255, 192, 119, 0.3)",transparent:!0,opacity:.5}),t.setAttribute("position",{x:0,y:0,z:.075});let e=document.createElement("a-entity");this.energyIndicator=e,this.energyIndicatorDimensions={width:this.hullDimensions.width-.005,height:this.hullDimensions.height-.005,depth:this.hullDimensions.depth-.005},e.setAttribute("geometry",Object.assign({primitive:"box"},this.energyIndicatorDimensions)),e.setAttribute("position",{x:0,y:0,z:0}),e.setAttribute("material",{color:"rgb(14, 128, 159)",transparent:!1}),t.appendChild(e),this.el.appendChild(t);let i=document.createElement("a-box");this.trigger=i,i.id="trigger",i.setAttribute("width",.02),i.setAttribute("height",.02),i.setAttribute("depth",.015),i.setAttribute("material",{color:"rgb(14, 128, 159)"}),i.setAttribute("position",{x:.02,y:0,z:.05}),i.setAttribute("rotation",{x:0,y:-5,z:0}),this.el.appendChild(i)},init:function(){console.log("init magicLight"),this.sceneEl=document.querySelector("a-scene"),this.gameState=this.system=this.sceneEl.systems["game-state"],this.createModel(),this.triggerPressed=!1,this.triggerTime=-1,this.el.addEventListener("buttondown",()=>{this.triggerPressed=!0,trigger.setAttribute("rotation",{x:0,y:-30,z:0}),this.triggerTime=this.gameState.time}),this.el.addEventListener("buttonup",()=>{this.triggerPressed=!1,trigger.setAttribute("rotation",{x:0,y:-5,z:0}),this.triggerTime=-1}),this.el.addEventListener("click",t=>{console.log(t.detail.intersectedEl.id)});var t={hand:this.data.hand,model:!1,rotationOffset:"left"===this.data.hand?90:-90};this.el.setAttribute("vive-controls",t),this.el.setAttribute("oculus-touch-controls",t),this.el.setAttribute("daydream-controls",t),this.el.setAttribute("gearvr-controls",t)},update:function(t){if(t.energy===this.data.energy)return;this.data.energy=Math.max(this.data.energy,0);const e=this.data.energy,i=e/this.data.maxEnergy;this.energyIndicator.setAttribute("geometry","depth",this.energyIndicatorDimensions.depth*(e/this.data.maxEnergy)),this.textTemplate=e<=3500?`${e}`:`Energy: ${e}`,this.energyIndicator.setAttribute("position",{x:0,y:0,z:-this.energyIndicatorDimensions.depth/2*(this.data.maxEnergy-e)/this.data.maxEnergy}),this.energyIndicator.setAttribute("material",{color:`hsl(${130*i}, 41%, 58%)`})}});`\n\nvarying vec2 vUv;\nvarying vec4 worldPosition;\nvarying vec3 u_cameraPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vUv = uv;\n  worldPosition = modelMatrix * vec4(position, 1.0);\n  vNormal = normal;\n  vec4 v = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  gl_Position = v;\n}\n`,`\n\n#define PI 3.1415926538\n\nuniform vec3 color;\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec3 u_controllerPos;\nuniform vec3 u_controllerLookDir;\nuniform bool u_controllerActive;\nuniform float u_triggerDuration;\n\nvarying vec2 vUv;\nvarying vec4 worldPosition;\nvarying vec3 vNormal;\n\nvoid main(void)\n{\n  vec3 controllerDir = u_controllerPos - worldPosition.xyz;\n  float dist = length(controllerDir);\n\n  \n  \n  float shadow = dot(vNormal, normalize(vec3(0.0, 0.3, 0.5)));\n  \n  \n  // add rippling effect to color\n  float ripple = sin(u_time + dist*5.0);\n  vec3 shadedColor = mix(color * shadow, vec3(ripple), 0.1);\n\n  \n  controllerDir = normalize(controllerDir);\n  float d = dot(u_controllerLookDir, controllerDir);\n  float angle = acos(d) / PI;\n  \n  float normDist = min(dist, 1.0);\n  if(u_controllerActive == true) {\n    float triggerDurSecs = u_triggerDuration / 1000.0;\n    float durOpacity = max(0.3, 1.0 - triggerDurSecs * 0.4);\n    float angleOpacity = angle * 10.0;\n    \n    float opacity = durOpacity * angleOpacity;\n    opacity = max(min(normDist, 0.4),  opacity);\n      \n    gl_FragColor = vec4(shadedColor, opacity);\n  } else {\n    gl_FragColor = vec4(shadedColor, 1.0);\n  }\n  \n\n  \n}\n`;AFRAME.registerComponent("labyrinth-material",{schema:{color:{default:"rgb(192, 214, 145)"}},init:function(){this.sceneEl=document.querySelector("a-scene"),this.gameState=this.sceneEl.systems["game-state"];const t=this.data;this.material=new THREE.ShaderMaterial({uniforms:{u_time:{value:0},color:{value:new THREE.Color(t.color)},u_controllerPos:{value:this.gameState.magicLight.object3D.position},u_controllerLookDir:{value:this.gameState.magicLight.object3D.getWorldDirection()},u_controllerActive:{value:this.gameState.magicLight.triggerPressed},u_triggerDuration:{value:this.gameState.time-this.gameState.magicLight.triggerTime},u_cameraPos:{value:this.gameState.camera.object3D.position}},vertexShader:"\n\nvarying vec2 vUv;\nvarying vec4 worldPosition;\nvarying vec3 u_cameraPos;\nvarying vec3 vNormal;\n\nvoid main() {\n  vUv = uv;\n  worldPosition = modelMatrix * vec4(position, 1.0);\n  vNormal = normal;\n  vec4 v = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  gl_Position = v;\n}\n",fragmentShader:"\n\n#define PI 3.1415926538\n\nuniform vec3 color;\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec3 u_controllerPos;\nuniform vec3 u_controllerLookDir;\nuniform bool u_controllerActive;\nuniform float u_triggerDuration;\n\nvarying vec2 vUv;\nvarying vec4 worldPosition;\nvarying vec3 vNormal;\n\nvoid main(void)\n{\n  vec3 controllerDir = u_controllerPos - worldPosition.xyz;\n  float dist = length(controllerDir);\n\n  \n  \n  float shadow = dot(vNormal, normalize(vec3(0.0, 0.3, 0.5)));\n  \n  \n  // add rippling effect to color\n  float ripple = sin(u_time + dist*5.0);\n  vec3 shadedColor = mix(color * shadow, vec3(ripple), 0.1);\n\n  \n  controllerDir = normalize(controllerDir);\n  float d = dot(u_controllerLookDir, controllerDir);\n  float angle = acos(d) / PI;\n  \n  float normDist = min(dist, 1.0);\n  if(u_controllerActive == true) {\n    float triggerDurSecs = u_triggerDuration / 1000.0;\n    float durOpacity = max(0.3, 1.0 - triggerDurSecs * 0.4);\n    float angleOpacity = angle * 10.0;\n    \n    float opacity = durOpacity * angleOpacity;\n    opacity = max(min(normDist, 0.4),  opacity);\n      \n    gl_FragColor = vec4(shadedColor, opacity);\n  } else {\n    gl_FragColor = vec4(shadedColor, 1.0);\n  }\n  \n\n  \n}\n",transparent:!0}),this.applyToMesh(),this.el.addEventListener("model-loaded",()=>this.applyToMesh())},update:function(){this.material.uniforms.color.value.set(this.data.color)},applyToMesh:function(){const t=this.el.getObject3D("mesh");t&&(t.material=this.material)},tick:function(t,e){this.material.uniforms.u_time.value=t/1e3,this.material.uniforms.u_controllerPos.value=this.gameState.magicLight.object3D.position,this.material.uniforms.u_controllerLookDir.value=this.gameState.magicLight.object3D.getWorldDirection(),this.material.uniforms.u_cameraPos=this.gameState.camera.object3D.position;let i=this.gameState.magicLight.components["magic-light"].triggerPressed;this.material.uniforms.u_controllerActive.value=i,this.material.transparent=!0,i&&(this.material.transparent=!0,this.material.uniforms.u_triggerDuration.value=this.gameState.time-this.gameState.magicLight.components["magic-light"].triggerTime)}});`\n\nvarying vec2 vUv;\nvarying vec4 worldPosition;\nvarying vec3 u_cameraPos;\n\n\n\nvoid main() {\n  vUv = uv;\n  worldPosition = modelMatrix * vec4(position, 1.0);\n  vec4 v = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  gl_Position = v;\n}\n`,`\n\n#define PI 3.1415926538\n\nuniform float u_time;\nuniform vec3 color;\nuniform vec2 u_resolution;\nuniform vec3 u_controllerPos;\nuniform vec3 u_controllerLookDir;\nuniform bool u_controllerActive;\nuniform float u_triggerDuration;\nuniform vec3 u_velocity;\n\nvarying vec4 worldPosition;\nvarying vec2 vUv;\n\nvoid main(void)\n{\n  vec2 st = gl_FragCoord.xy / u_resolution.xy;\n  vec3 controllerDir = u_controllerPos - worldPosition.xyz;\n  float dist = length(controllerDir) * 0.15;\n  \n\n  controllerDir = normalize(controllerDir);\n  float dot = dot(u_controllerLookDir, controllerDir);\n  float angle = acos(dot) / PI;\n  \n  if(!u_controllerActive) {\n      angle = 1.0 - length(u_velocity) * 800.0;\n  }\n  \n  float sharpAngle = smoothstep(0.0, 0.2, angle);\n  \n\n  vec2 toCenter = vec2(0.5) - vUv;\n  float planeAngle = atan(toCenter.y,toCenter.x);\n  float planeDist = distance(vUv, vec2(0.5)) * 2.0;\n  \n  float num = 10.0;\n  float grayscale = abs(sin(planeAngle * num/2.0));\n\n  grayscale = mix(grayscale, planeDist, sin(u_time * 2.0) * 2.0);\n  \n  vec3 mask = vec3(step(grayscale, 0.5));\n  \n  // Final color is the mask, transparency too, but is scaled by angle to controller\n  // and speed of stone\n  vec3 colorRainbow = vec3(sin(u_time), sin(u_time * 2.), length(toCenter));\n  colorRainbow = mix(colorRainbow, color, 0.7);\n  gl_FragColor = vec4(mask * colorRainbow,  mask.x * (1.0 - sharpAngle));\n  \n  \n  \n  \n}\n`;AFRAME.registerComponent("lost-stone-material",{schema:{color:{default:"rgb(14, 128, 159)"}},init:function(){this.sceneEl=document.querySelector("a-scene"),this.gameState=this.sceneEl.systems["game-state"];const t=this.data;this.material=new THREE.ShaderMaterial({uniforms:{u_time:{value:0},color:{value:new THREE.Color(t.color)},u_controllerPos:{value:this.gameState.magicLight.object3D.position},u_controllerLookDir:{value:this.gameState.magicLight.object3D.getWorldDirection()},u_controllerActive:{value:this.gameState.magicLight.triggerPressed},u_triggerDuration:{value:this.gameState.time-this.gameState.magicLight.triggerTime},u_velocity:{value:new THREE.Vector3(0,0,0)}},vertexShader:"\n\nvarying vec2 vUv;\nvarying vec4 worldPosition;\nvarying vec3 u_cameraPos;\n\n\n\nvoid main() {\n  vUv = uv;\n  worldPosition = modelMatrix * vec4(position, 1.0);\n  vec4 v = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  gl_Position = v;\n}\n",fragmentShader:"\n\n#define PI 3.1415926538\n\nuniform float u_time;\nuniform vec3 color;\nuniform vec2 u_resolution;\nuniform vec3 u_controllerPos;\nuniform vec3 u_controllerLookDir;\nuniform bool u_controllerActive;\nuniform float u_triggerDuration;\nuniform vec3 u_velocity;\n\nvarying vec4 worldPosition;\nvarying vec2 vUv;\n\nvoid main(void)\n{\n  vec2 st = gl_FragCoord.xy / u_resolution.xy;\n  vec3 controllerDir = u_controllerPos - worldPosition.xyz;\n  float dist = length(controllerDir) * 0.15;\n  \n\n  controllerDir = normalize(controllerDir);\n  float dot = dot(u_controllerLookDir, controllerDir);\n  float angle = acos(dot) / PI;\n  \n  if(!u_controllerActive) {\n      angle = 1.0 - length(u_velocity) * 800.0;\n  }\n  \n  float sharpAngle = smoothstep(0.0, 0.2, angle);\n  \n\n  vec2 toCenter = vec2(0.5) - vUv;\n  float planeAngle = atan(toCenter.y,toCenter.x);\n  float planeDist = distance(vUv, vec2(0.5)) * 2.0;\n  \n  float num = 10.0;\n  float grayscale = abs(sin(planeAngle * num/2.0));\n\n  grayscale = mix(grayscale, planeDist, sin(u_time * 2.0) * 2.0);\n  \n  vec3 mask = vec3(step(grayscale, 0.5));\n  \n  // Final color is the mask, transparency too, but is scaled by angle to controller\n  // and speed of stone\n  vec3 colorRainbow = vec3(sin(u_time), sin(u_time * 2.), length(toCenter));\n  colorRainbow = mix(colorRainbow, color, 0.7);\n  gl_FragColor = vec4(mask * colorRainbow,  mask.x * (1.0 - sharpAngle));\n  \n  \n  \n  \n}\n",transparent:!0,visible:!0}),this.applyToMesh(),this.el.addEventListener("model-loaded",()=>this.applyToMesh())},update:function(){this.material.uniforms.color.value.set(this.data.color)},applyToMesh:function(){const t=this.el.getObject3D("mesh");t&&(t.material=this.material)},tick:function(t,e){this.material.uniforms.u_time.value=t/1e3,this.material.uniforms.u_velocity.value=this.el.components["physics-body"].velocity,this.material.uniforms.u_controllerPos.value=this.gameState.magicLight.object3D.position,this.material.uniforms.u_controllerLookDir.value=this.gameState.magicLight.object3D.getWorldDirection();let i=this.gameState.magicLight.components["magic-light"].triggerPressed;this.material.uniforms.u_controllerActive.value=i,i&&(this.material.uniforms.u_triggerDuration.value=this.gameState.time-this.gameState.magicLight.triggerTime)}})}();